<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Ryan" />



<meta name="description" content="这个冬天有点冷，冬天了还是储藏点过冬的粮食，用倒推法来总结相关知识，这篇博客将会长期更新，收集网上的面试题，然后自己整理思路，以后自己肯定会用的上，也为以后博客积累素材。">
<meta name="keywords" content="Interview,Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java后端面试题整理">
<meta property="og:url" content="https://ruanzz.github.io/2018/12/18/interview-summary/index.html">
<meta property="og:site_name" content="Ryan&#39;s Blog">
<meta property="og:description" content="这个冬天有点冷，冬天了还是储藏点过冬的粮食，用倒推法来总结相关知识，这篇博客将会长期更新，收集网上的面试题，然后自己整理思路，以后自己肯定会用的上，也为以后博客积累素材。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ruanzz.github.io/asset/img/interview-summary/tcp_shake_hand.jpg">
<meta property="og:updated_time" content="2019-04-13T12:38:17.742Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java后端面试题整理">
<meta name="twitter:description" content="这个冬天有点冷，冬天了还是储藏点过冬的粮食，用倒推法来总结相关知识，这篇博客将会长期更新，收集网上的面试题，然后自己整理思路，以后自己肯定会用的上，也为以后博客积累素材。">
<meta name="twitter:image" content="https://ruanzz.github.io/asset/img/interview-summary/tcp_shake_hand.jpg">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Ryan&#39;s Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Java后端面试题整理 | Ryan&#39;s Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/asset/img/Wellington.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Ryan</a></h1>
        </hgroup>

        
        <p class="header-subtitle">永远相信美好事情即将发生</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/whoami/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Ryan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/asset/img/Wellington.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Ryan</a></h1>
            </hgroup>
            
            <p class="header-subtitle">永远相信美好事情即将发生</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/whoami/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-interview-summary" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/18/interview-summary/" class="article-date">
      <time datetime="2018-12-18T21:47:55.000Z" itemprop="datePublished">2018-12-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java后端面试题整理
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Interview/">Interview</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/">Interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <!-- ![惠灵顿](/asset/img/interview-summary/Mac.jpeg) -->
<p>这个冬天有点冷，冬天了还是储藏点过冬的粮食，用倒推法来总结相关知识，这篇博客将会长期更新，收集网上的面试题，然后自己整理思路，以后自己肯定会用的上，也为以后博客积累素材。<br><a id="more"></a></p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><blockquote>
<p>1.String类有看过源码吗？和StringBuffer，StringBuilder有什么区别？</p>
</blockquote>
<p>String类是一个final不可修改的类,说明String类不能被继承，StringBuffer和StringBuilder都是用来拼接字符串用的，只有调用toString()方法的时候才会真正的new String()对象，定义字符串的时后字符量拼接是由JVM进行优化拼接成整体放入字符串常量池中，如果有字符串变量参与了字符串的拼接，那么底层是调用StringBuilder来进行拼接。StringBuffer是线程安全的，StringBuilder是线程不安全的，因此StringBuilder的性能会更好一点，有并发场景的话还是使用StringBuffer来比较合适。</p>
<blockquote>
<p>2.Throwable、Error、Exception区别和联系。受查异常和非受查异常都用过哪些，谈一下对他们的理解</p>
</blockquote>
<p>Throwable 是异常的顶层类，Error和Exception都继承了这个类，当然还有其他一些子类，在我们开发过程中常接触到也就是这两个类的子类，算是两种比较常用的异常处理。Error代表出现了非常严重的错误，JVM虚拟机无法处理，只能Crash，比如OutOfMemoryError。Exception是一般性的异常，这个一般性指的是不会造成虚拟机宕机，但是对开发人员来说，最复杂的也就是这块，对异常的处理是根据业务来的，是抛出去还是try起来，怎么对异常分类？这个都要根据具体的业务来决定，跟业务相关复杂性肯定不会小，因此如何处理好异常也是很有门道的。<br>Exception和Error本来是互不相关的，但是Exception中有一个叛徒RuntimeException，这个叛徒却是最受开发人员欢迎的，基本上自定义业务一样都会继承它，为什么说他是叛徒呢？它和Error一样，都是都是unchecked的，程序都会进行中止处理，除RuntimException及其子类外的Exception都是checked的，受查异常和非受查异常在在编译过程中就有体现出来，受查异常必须在代码层面做处理，不然编译不通过。常用的非受查异常有OutOfMemoryError,ClassCastException,NullPointerException等，常用的受查异常有：FileNotFoundException，NumberFormatException，NoSuchMethodException，IOException，ClassNotFoundException，InterruptedException等</p>
<blockquote>
<p>3.父类和子类之间加载的时候，代码块，构造块，构造方法，普通方法调用的顺序</p>
</blockquote>
<p>static静态成员变量或者静态代码块是JVM启动的时候加载，所以会优先执行这个，大概的顺序是代码块优先于构造方法，静态优先于非静态。执行的顺序如下：<br>1.父类静态成员变量和静态代码块<br>2.子类静态成员变量和静态代码块<br>3.父类普通成员变量和普通代码块<br>4.父类构造方法<br>5.子类普通成员变量和普通代码块<br>6.子类构造方法</p>
<blockquote>
<p>4.Java泛型有什么好处？是怎么实现的?</p>
</blockquote>
<p>泛型的的好处就是在编译的时候检查类型安全，把运行时异常提前到编译时异常，并且所有的强制转换都是自动和隐式转换，提高了代码的重用，不用到处都是显式的强制转换，让代码更加优雅。<br>Java泛型的实现原理是类型擦除，是在编译器这个层次来实现。什么是类型擦除呢？就是使用泛型的时候加上的类型参数，在编译的时候去掉，在生成的Java字节码文件中是不包含泛型中的类型信息的。比如，定义了一个<code>List&lt;String&gt;</code>类型，在编译之后都会变成<code>List</code>类型，JVM看到的只是<code>List</code>，而由泛型附加的类型信息是对JVM来说是透明的。</p>
<blockquote>
<p>5.说说你对面向对象、封装、继承、多态的理解。</p>
</blockquote>
<ul>
<li>封装 隐藏具体的实现细节，并且明确标识允许外部使用的成员方法和成员变量，防止数据被破坏。</li>
<li>继承 子类继承父类，拥有父类除private修饰的所有成员变量和成员方法，并且可以在父类基础上进行扩展，实现了代码的重用。</li>
<li>多态 一个接口有多个子类或者多个实现类，在运行期间(非编译期间)才决定所引用的对象的实际类型，再根据其实际的类型调用其对应的方法，也就是常说的”动态绑定“。有三个条件：继承、重写、向上转型。因此面试的时候往往就是说说多态的理解，这样子面向对象编程的精髓基本都会涉及了。<br>(1) 继承： 子类继承父类或者实现父类<br>(2) 重写： 子类重写从父类继承过来的方法<br>(3) 向上转型： 父类引用指向子类</li>
</ul>
<blockquote>
<p>6.private修饰的方法可以通过反射访问，那么private的意义是什么？</p>
</blockquote>
<p>private只是封装、OOP思想的一种体现，与安全什么的毫无关系。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><blockquote>
<p>1.Java的集合类框架介绍一下</p>
</blockquote>
<p>最顶层接口是分别是Collection和Map<br>【Collection】<br>Collection的实现类有List、Set和Queue。List的实现类有ArrayList和LinkedList等，ArrayList是一个可扩容的对象数组，LinkedList是一个双向链表。Set里的元素是不可重复，常见的有HashSet，TreeSet，LinkedHashSet等，HashSet的实现基于HashMap，实际上就是HashMap中的key。Queue的实现类有LinkedList，可以用作栈，队列和双向队列，另外还有ArrayBlockingQueue等。<br>【Map】<br>Map的实现类常见的有HashMap，TreeMap，LinkedHashMap和HashTable等，HashMap使用散列法实现，底层是数组+链表。TreeMap是根据键排好序的Map，使用红黑树实现。LinkedHashMap的实现综合了HashMap和双向链表，可保证以插入时的顺序进行迭代访问。HashTable和HashMap相比，HashTable是线程安全的，HashMap是线程不安全的，HashTable的键或值不允许为null，HashMap允许。</p>
<blockquote>
<p>2.集合容器类中使用了哪些设计模式？</p>
</blockquote>
<p>（1）迭代器模式，Collection继承了Iterable接口，其中的Iterator()方法返回Iterator对象，通过这个对象可以迭代Collection中的元素。<br>（2）适配器模式 <code>java.util.Arrays#asList()</code>可以将数组类型转换为<code>List</code>数据类型。</p>
<blockquote>
<p>3.ArrayList源码分析</p>
</blockquote>
<p><code>ArrayList</code>实现了<code>RandomAccess</code>接口，支持随机访问，底层是基于数组来实现，数组默认大小为10。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>（1）扩容   添加元素时使用<code>ensureCapacityInternal()</code>方法来保证容量足够，如果不够时，需要使用<code>grow()</code>方法来进行扩容,新容量的大小为<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>,也就是1.5倍。扩容操作需要调用<code>Arrays.copyOf()</code>方法把原数组整个复制到新数组中，因此最好在创建ArrayList的时候就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>(2)删除元素 需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>(3)Fail-Fast机制  modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>(4)序列化机制 ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure></p>
<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>4.Vector源码分析</p>
</blockquote>
<p>实现大体上与ArrayList类似，但是使用synchronized进行同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E var1)</span> </span>&#123;</span><br><span class="line">    ++<span class="keyword">this</span>.modCount;</span><br><span class="line">    <span class="keyword">this</span>.ensureCapacityHelper(<span class="keyword">this</span>.elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.elementCount++] = var1;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 &gt;= <span class="keyword">this</span>.elementCount) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.elementData(var1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>Vector是同步的，因此开销肯定比ArrayList大，访问速度更慢，因此不建议使用，应该使用ArrayList，如果需要到同步，可以使用<code>Collections.synchronizedList()</code>得到一个线程安全的ArrayList,或者使用concurrent包下的CopyOnWriteArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br><span class="line">List&lt;String&gt; copyOnWriteList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5.CopyOnWriteArrayList源码分析</p>
</blockquote>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>CopyOnWriteArrayList</code>在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。但是<code>CopyOnWriteArrayList</code>有其缺陷：<br>(1)内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>(2)数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以<code>CopyOnWriteArrayList</code>不适合内存敏感以及对实时性要求很高的场景。</p>
<blockquote>
<p>6.LinkedList源码分析</p>
</blockquote>
<p>基于双向链表实现，使用Node存储链表节点信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>并且每个链表存储了first和last指针：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></p>
<p>跟ArrayList相比：<br>(1)ArrayList基于动态数组实现，LinkedList基于双向链表实现<br>(2)ArrayList支持随机访问，LinkedList不支持<br>(3)LinkedList在任意位置添加删除元素更快</p>
<blockquote>
<p>7.HashMap源码分析(JDK1.7)</p>
</blockquote>
<p>(1)存储结构<br>包含一个Entry类型的数组table,Entry存储着键值对，包含了四个字段，从netx字段可以看出Entry是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap使用拉链法来解决冲突，同一个链表中存放哈希值相同的Entry。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)拉链法原理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"k1"</span>,<span class="string">"v1"</span>);</span><br><span class="line">map.put(<span class="string">"k2"</span>,<span class="string">"v2"</span>);</span><br><span class="line">map.put(<span class="string">"k3"</span>,<span class="string">"v3"</span>);</span><br></pre></td></tr></table></figure></p>
<p>新建一个HashMap,默认大小为16，插入&lt;k1,v1&gt;键值对，假设k1的hashcode为115，则115%16=3，则在table[3]插入&lt;k1,v1&gt;这个Entry，假设k2和k3的hashcode都是118，118%16=6，那么&lt;k2,v2&gt;和&lt;k3,v3&gt;都是插入table[6]这个桶内，&lt;k3,v3&gt;在&lt;k2,v2&gt;前面，即&lt;k3,v3&gt;的next元素是&lt;k2,v2&gt;,每次插入元素都是直接插入链表的表头。</p>
<p>(3)get操作<br>查找需要分为两步：<br>①计算键值对所在的桶<br>②在链表上顺序查找，时间复杂度显然和链表的长度成正比。</p>
<p>如何确定键值对的桶下标呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是两步，先计算hash值，然后对table长度取模。计算hash值这个方法很常规，关键是取模indexFor()这个方法很有意思，正常的写法应该是<code>h%length</code>,但是jdk源码里边写的是<code>h&amp;(length-1)</code>,第一次看到这个的时候我就愣了，jdk源码应该不会有这么大的bug！这两相等？研究了一下之后发现都是写代码的，人与人之间的差别不是一丁半点！！！</p>
<p>假设x=1&lt;&lt;4,即x为2的4次方，y的值为10110010<br>正常人取模：y%x<br>y:10110010<br>x:00010000<br>y%x:00000010<br>大神取模：y&amp;(x-1)<br>y:10110010<br>x-1:00001111<br>y&amp;(x-1):00000010</p>
<p>位运算的代价比求模运算小的多，因此带来更高的性能。但是这个有一个前提就是x必须是2的n次方，这样子x-1就会是一堆的1，和y做与运算之后就把y的高位干掉，只剩下低位，达到取模效果，这个不得不佩服！</p>
<p>(4)put操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HashMapy允许插入键为null的键值对，但是无法调用null的hashCode()方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap使用第0个桶存放键为null的键值对。<br>对于键不是null的键值对，使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<p>(5) 扩容原理<br>假设HashMap的table长度为M，需要存储的键值对数量为N，如果哈希函数满足均匀性的要求，那么每条链表的长度为N/M,因此平均查找次数的复杂度为O(N/M)。<br>为了让查找的成本降低，应该尽可能使得N/M尽可能小，因此需要M足够大，HashMap采用动态扩容来根据当前的N值来调整M值，使得空间效率和时间效率都得到保证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 初始容量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最大容量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 默认负载因子 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Entry数组 */</span></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 键值对数量 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 阈值 */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 负载因子 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 修改次数 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<p>当需要size大于threshold时，需要进行扩容操作，capacity为原来的两倍，扩容操作需要把oldTable中的所有键值对重新插入newTable中，这个步骤是非常耗时的。因此，如果知道table大小的话最好通过构造函数传入，避免后续扩容造成性能问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，扩容之后把原来table的entry复制到新的table中，并且table长度变了，那原来的hash值又要重新计算一遍？是的！HashMap使用了一个特殊的机制，可以降低重新计算桶下标的操作，假设原来的table长度为16(00010000)，扩容之后的table长度为32(00100000)，对于一个key，如果它的hash值第五位上为0，那么取模结果和以前一样，如果为1，那么得到的结果为原来的加上16。</p>
<p>(6)计算table容量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>8.ConcurrentHashMap源码分析(JDK1.7)</p>
</blockquote>
<p><code>ConcurrentHashMap</code>和<code>HashMap</code>实现上类似，最主要区别是<code>ConcurrentHashMap</code>采用了分段锁(Segment),每个分段锁维护着几个同(HashEntry),多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高，并发度就是Segment的个数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 默认的并发级别为 16，也就是说默认创建 16 个 Segment */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure></p>
<p>每个Segment维护一个count变量来统计该Segment中的键值对个数，在执行size()方法时，需要遍历所有的Segment然后把count累计起来。ConcurrentHashMap在执行size()时，先尝试不加锁获取，如果连续两次不加锁获取的结果一致，那么可以认为这个结果是正确的。尝试次数超过3次，就需要对每个Segment进行加锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。JDK 1.8 使用了CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁 synchronized。</p>
<blockquote>
<p>9.LinkedHashMap源码分析(JDK1.7)</p>
</blockquote>
<p><code>LinkedHashMap</code>继承自HashMap，因此有HashMap的所有特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>内部维护了一个双向列表，用来维护插入顺序或者LRU顺序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></p>
<p>LinkedHashMap最重要的是以下用于对维护顺序的函数afterNodeAccess()和afterNodeInsertion()，会在put、get等方法中调用。</p>
<p>当一个节点被使用时，调用get方法，如果assessOrder为true，则会将该节点移到链表尾部。也就是说指定为LRU顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行put操作之后，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。evict 只有在构建 Map 的时候才为 false，在这里为 true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote>
<p>1.Java中有几种方式可以创建线程？</p>
</blockquote>
<ul>
<li>继承<code>Thread</code>并重写<code>run</code>方法</li>
<li>实现<code>Runnable</code>接口并重写<code>run()</code>方法，并将作为参数传入<code>Thread</code></li>
<li>实现<code>Callable</code>接口并重写<code>call()</code>方法，<code>call()</code>方法有返回值</li>
<li>由线程池创建并管理线程</li>
</ul>
<blockquote>
<p>2.Java线程池怎么实现的？主要核心类讲一下</p>
</blockquote>
<p><code>Executors</code>是线程池的工厂类，通过调用它的静态方法来创建线程池，比如<code>newCachedThreadPool()</code>方法，这些静态方法统一返回一个<code>ThreadPoolExecutor</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                        RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数解释：</p>
<ul>
<li>corePoolSize: 指定线程池中线程的数量</li>
<li>maximumPoolSize: 线程池中最大的线程数量</li>
<li>keepAliveTime: 当线程池中的线程数量超过corePoolSize的时候，多余的线程最大的存活时间</li>
<li>unit: keepAliveTime的单位</li>
<li>workQueue: 任务队列，被提交但还未被执行的任务</li>
<li>threadFactory: 线程工厂，用于创建线程</li>
<li>handler: 拒绝策略，当任务太多来不及处理的时候，采用什么方式拒绝任务</li>
</ul>
<p>核心参数: workQueue和handler<br>【workQueue】<br>有<code>ArrayBlockingQueue</code>有界队列，<code>LinkedBlockingQueue</code>无界队列，<code>SynchronousQueue</code>直接提交队列<br><code>ArrayBlockingQueue</code>：当线程池中实际线程数小于corePoolSize时，直接创建线程执行任务，当大于corePoolSize时，提交到workQueue中，因为这个队列是有界的，当队列满时，在不大于maximumPoolSize的情况下，创建线程执行任务，如果大于maximumPoolSize，执行拒绝策略handler<br><code>LinkedBlockingQueue</code>：当线程池中实际线程数小于corePoolSize时，直接创建线程执行任务，当大于corePoolSize小于maximumPoolSize时，提交到workQueue中，因为队列是无界的，所以之后提交的任务都会进入队列中<br><code>SynchronousQueue</code>：该队列没有容量，对提交的任务不做保存，直接新增线程来执行任务。</p>
<p>【handler】</p>
<ul>
<li>直接抛异常</li>
<li>在调用者的线程中执行当前任务</li>
<li>丢弃最老的一个请求，将队列头的任务poll出去</li>
<li>直接丢弃无法处理的任务，不做任何处理</li>
</ul>
<blockquote>
<p>3.如何终止线程？</p>
</blockquote>
<ul>
<li>调用线程interrupt()方法，执行线程体业务代码之前使用interrupted()方法进行判断是否被中断，只有为false才会执行线程体,调用线程interrupt()方法之后线程体业务代码就不会再被执行。</li>
<li>直接调用线程的stop()方法，这是jdk6以前的做法，现在是不推荐了，因为会导致线程不释放锁，有可能会出现死锁情况。</li>
</ul>
<blockquote>
<p>4.说一下原子性，有序性，可见性</p>
</blockquote>
<ul>
<li>原子性：一个操作或者多个操作，要么全部执行成功，要么全部不执行。</li>
<li>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他的线程能够立即看得到修改的值</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行，不进行执行重排。</li>
</ul>
<blockquote>
<p>5.说一下Object对象的notify()和wait()方法</p>
</blockquote>
<p>Object对象中notify()和wait()是用来实现等待/通知模式，调用wait()方法之后线程进行等待状态，等待状态中的线程可以通过notify()方法唤醒并继续执行。等待和阻塞不同，阻塞状态的线程需要获取新的锁。wait()、notify()和notifyAll()方法需要配合synchronized使用。</p>
<blockquote>
<p>6.Synchronized实现原理</p>
</blockquote>
<p>synchronized可以保证方法或者代码块在执行时，同一时刻只有一个线程访问，同时还保证了共享变量的内存可见性。Java中的每一个对象都可以作为锁，属于重量级锁，jdk1.6之后进行了优化，由轻量级向重量级升级，偏向锁-&gt;自旋锁-&gt;轻量级锁-&gt;重量级锁来减少锁操作的开销。</p>
<ul>
<li>同步代码块：同步代码块锁的是括号里边的对象，monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之对应，当Monitor被持有之后，它将处于锁定状态，线程执行到monitorenter指令时，将会尝试获取对象所对应的Monitor所有权，即尝试获取对象的锁。</li>
<li>同步方法：synchronized方法在JVM层面并没有任何特别的指令来实现被Synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中synchronized标识位设置为1，表示方法是同步方法，并使用调用该方法的对象或该方法所属的class在JVM的内部对象做为锁对象。</li>
</ul>
<blockquote>
<p>7.volatile实现原理</p>
</blockquote>
<p>volatile是轻量级的锁，它不会引起上下文的切换和调度。</p>
<ul>
<li>可见性：对一个volatile修饰的变量进行读操作，总可以看到对这个变量最终的写。</li>
<li>原子性：对一个volatile修饰的变量读写具有原子性，但是符合操作除外，例如i++。</li>
<li>禁止重排：JVM底层采用内存屏障来实现volatile语义，防止指令重排序。<br>鉴于这三个特性，volatile经常用于这两个场景：状态标记常量，Double Check。</li>
</ul>
<blockquote>
<p>8.锁的分类，都有那些锁？</p>
</blockquote>
<ul>
<li>可重入锁：在一个线程中可以多次获取同一把锁，ReentrantLock和synchronized都是可重入锁。</li>
<li>可中断锁：可以中断相应的锁，synchronized不是可中断的锁，Lock是可中断锁。</li>
<li>公平锁：尽量以请求锁的顺序来获取锁。synchronized是非公平锁，Lock默认是非公平的，但是可以设置成公平锁。</li>
</ul>
<blockquote>
<p>9.说一下ReentrantLock锁</p>
</blockquote>
<p>ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。可以等同于synchronized的使用，但是ReentrantLock提供了更加强大，灵活的锁机制，可以减少死锁发生的概率。ReentrantLock实现了Lock接口，基于内部sync实现，Sync实现AQS,提供了FairSync和NonFairSync两种实现。Condition和Lock一起使用以实现等待/通知模式，通过await()和signal()来阻塞和唤醒线程。</p>
<blockquote>
<p>10.说一下读写锁</p>
</blockquote>
<p>ReentrantReadWriteLock维护一对锁，一个读锁，一个写锁，并发性得到较大的提升。在同一时间内，可以允许多个读线程进行访问，但是，在写线程访问时，所有读线程和写线程都会被阻塞。</p>
<blockquote>
<p>11.AQS队列同步器</p>
</blockquote>
<p>AQS是构建锁或者其他同步组件基础框架，包含了实现同步器的细节(获取同步状态，FIFO同步队列)。AQS的主要使用方式是继承，子类通过继承AQS,并实现它的抽象方法来管理同步状态。</p>
<ul>
<li>维护一个同步状态state，当state&gt;0时，表示已经获取了锁，当state==0时，表示释放了锁。</li>
<li>AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败(锁)时，AQS则会将当前线程以及等待状态等信息构造成一个节点并将其加入同步队列，同时阻塞当前线程。当同步线程释放时，则会把节点中的线程唤醒，使其再次获取同步状态。</li>
</ul>
<blockquote>
<p>12.synchronized和Lock的区别</p>
</blockquote>
<ul>
<li>Lock是一个接口，synchronized是Java中的关键字，是语言的内置特性。</li>
<li>synchronized在发生异常时，会自动释放所占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能发生死锁现象，因此，使用Lock时需要在finally块中释放锁。</li>
<li>Lock可以让等待的线程响应中断，而synchronized不行，使用synchronized时，等待的线程会一直等待下去，不能响应中断。</li>
<li>通过Lock可以知道是否获成功获取锁，而synchronized无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。</li>
</ul>
<blockquote>
<p>13.说一下CAS</p>
</blockquote>
<p>Compare And Swap 比较交换，synchronized保证了代码块的原子性，但是会引起性能问题，volatile是不错的选择，但是不能保证原子性。所以需要CAS来保证原子性。<br>CAS有三个参数，内存值V，旧的预期值A，要更新的值B，当且仅当内存值V的值等于旧的预期值A时，才会将内存值V修改为B，否则什么都不干。</p>
<blockquote>
<p>14.HashMap是线程安全的嘛？如何变得安全？</p>
</blockquote>
<p>不是线程安全的，添加元素到map中时，数据量大产生扩容操作，多线程导致HashMap的node链表形成环状的数据结构导致死循环，所以HashMap是线程不安全的。可以通过Collections.synchronizedMap()方法对HashMap进行包装，返回一个SynchronizedMap对象，在源码中SynchronizedMap也是通过synchronized方法来保证线程安全的。JUC包中的ConcurrentHashMap来进行高效安全并发，注意的是key和value都不能为null。</p>
<blockquote>
<p>15.ConcurrentHashMap的实现方式</p>
</blockquote>
<p>JDK1.7中采用分段锁和HashEntry使锁更加细化，其中Segment继承于ReentrantLock，理论上支持ConcurrentLevel(Segment数组数量)的线程并发。</p>
<p>JDK1.8采用CAS+synchronized来保证并发更新的安全，当然底层使用数组+链表+红黑树的存储结构。<br>table中存放Node节点数据，默认Node数据大小为16，扩容大小总是2^N,为了保证可见性，Node节点中的val和next节点都用volatile修饰，当链表长度大于8时，会转换成红黑树，节点会被包装成TreeNode放在TreeBin中。</p>
<ul>
<li>put操作:<ul>
<li>计算key对应的hash值，</li>
<li>如果hash表还未初始化，调用的intTable()进行初始化，否则在table中找到index位置，并通过CAS添加节点，如果链表长度超过8，则将链表转换为红黑树，如果节点总数超过，则进行扩容。</li>
</ul>
</li>
<li>get操作：<ul>
<li>无需加锁，直接根据key的hash值遍历node</li>
</ul>
</li>
</ul>
<blockquote>
<p>16.CountDownLatch和CyclicBarrier的区别</p>
</blockquote>
<p>CyclicBarrier允许一组线程相互等待，直到到达某个公共的屏障点，每个线程都调用await()方法，告诉CyclicBarrier我已经到达屏障，然后当前线程被阻塞，当所有的线程都到达了屏障，结束阻塞，所有的线程可继续执行后续逻辑。<br>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后再继续执行，使用一个计数器实现，计数器初始值为线程的数量，当每个线程完成自己任务后，计数器的值就会减一，当计数器的值为0时，表示所有的线程都完成了任务，然后CountDownLatch上等待的线程就可以恢复执行任务。</p>
<blockquote>
<p>17.什么是乐观锁和悲观锁？</p>
</blockquote>
<p>像synchronized这种独占锁属于悲观锁，它是在假设一定会发生冲突，那么加锁恰好有用，除此之外，还有乐观锁，乐观锁就是假设没有冲突发生，那么我正好可以进行某项操作，如果要是发生冲突呢？那我就重试直到成功，乐观锁最常见的就是CAS。</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><blockquote>
<p>1.ClassLoader的种类，父子关系(不一定是继承)，双亲委派机制，Java为什么要用双亲委派机制?</p>
</blockquote>
<p>【种类】<br>ClassLoader包括：引导类加载器(BoostrapClassLoader)、扩展类加载器(ExtensionsClassLoader)、应用类程序加载器(ApplicationClassLoader)、自定义类加载器</p>
<ul>
<li>引导类加载器：加载JVM自身需要的类，由C++实现，是虚拟机的一部分，负责将lib下和核心类库和-Xbootclasspath参数指定路径下的jar包加载到内存中，而且虚拟机加载的jar包的时候是根据jar包文件名来识别的，比如rt.jar,如果文件名不被虚拟机识别，即使把jar包放在lib下边也不会被加载，并且BootstrapClassLoader只加载包名为java、javax、sun等开头的类，这些都是为了虚拟机的安全考虑。</li>
<li>扩展类加载器：负责加载JAVA_HOME/lib/ext目录下或者由虚拟机参数指定的<code>-Djava.ext.dir</code>指定路径中的类库。</li>
<li>应用类程序加载器：ApplicationClassLoader是指sun公司实现的<code>sun.misc.Launcher$AppClassLoader</code>,负责加载系统类路径<code>java -classpath</code>或者<code>-Djava.class.path</code>下的类库，一般情况下，这个是默认的类加载器，通过<code>ClassLoader#getSystemClassLoader()</code>方法可以获取。</li>
<li>自定义类加载器：通过继承<code>java.lang.ClassLoader</code>并重写<code>findClass()</code>方法来实现。</li>
</ul>
<p>【父子关系】</p>
<ul>
<li>启动类加载器，由C++实现，没有父类</li>
<li>扩展类加载器，由Java实现，父类为Null，其实是启动类加载器，但是启动类加载器不是Java实现实现的，所以获取到的是Null</li>
<li>系统类加载器，由Java实现，父类加载器为扩展类加载器</li>
<li>自定义类加载器，由Java实现，父类加载器为系统类加载器</li>
</ul>
<p> 【双亲委派机制】<br> 如果一个类收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，请求最终到达顶层的启动类加载器，如果父类加载器可以完成加载任务，则成功返回，倘若父类加载器无法完成此加载任务，子类加载器才会去尝试加载，这就是双亲委派机制。但是这个翻译不应该叫双亲，应该叫好爸爸机制，因为子类都是不管怎样都是先丢给父类来加载，只有父类加载不了子类才会去加载。</p>
<p> 【双亲委派机制好处】<br> 为什么要用双亲委派机制呢？肯定是因为这种机制有某个好处使得官方采用。<br> （1）避免类的重复加载。当父类加载器加载了该类时，就没有必要子ClassLoader再加载一次。<br> （2）安全因素考虑，Java核心API中定义的类不会被改变，防止核心API库被随意修改。</p>
<blockquote>
<p>2.如何打破双亲委派机制?什么时候需要打破双亲委派机制？有哪些框架打破了双亲委派机制？</p>
</blockquote>
<p>打破双亲委派机制不仅要继承<code>java.lang.ClassLoader</code>重写<code>findClass()</code>方法，还要重写<code>loadClass()</code>方法，默认的<code>loadClass()</code>方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。因此为了打破双亲委派机制就必须重写<code>loadClass()</code>,可以在这个方法里边使用任何一个类加载器来加载，不一定优先由启动类加载器来加载，这样子就打破了双亲委派机制。</p>
<p>什么时候需要打破双亲委派机制呢？双亲委派机制很好的解决了各个类加载器的基础类统一问题，越基础的类越由上层的类加载器加载，基础类之所以叫做基础类，是因为他们总是作为被调方被别人调用，但是，如果基础类想调用户的代码，这个时候怎么办呢？这并非不可能的事，这个时候就需要打破双亲委派机制，一个典型的例子就是JNDI服务，它的代码由引导类启动器去加载，但是JNDI的目的就是对资源进行集中管理和查找，需要调用各个厂商实现部署在应用程序的classpath下的JNDI接口提供者(SPI)的代码，但是引导类加载器不认识这些代码，该如何解决呢？引入线程上下文加载器，这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个,如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型。还有一个就是OSGi,为了可以动态加载模块，每个模块都有自己类加载器，这些类加载器组成了网状结构，不再是双亲委派模型中的树状结构。</p>
<blockquote>
<p>3.JVM内存结构</p>
</blockquote>
<p>JVM内存结构主要有三大块：堆内存、方法区和栈。<br>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配<br>方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)<br>栈又分为java虚拟机栈和本地方法栈,主要用于方法的执行</p>
<blockquote>
<p>4.对象是否可GC</p>
</blockquote>
<p>这个问题其实就是JVM如何判断对象是否需要被回收，JVM使用可达性算法来计算一个对象是否可达。<br>算法思路：通过一些被列为”GC Roots“的对象作为起始点，从这些点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，则说明对象需要被回收。<br>可以作为GC Roots对象包括以下几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<blockquote>
<p>5.Minor GC、Major GC和 Full GC</p>
</blockquote>
<p>堆内存由年轻代和老年代组成。<br>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。<br>Major GC 是清理老年代。<br>Full GC 是清理整个堆空间—包括年轻代和老年代。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote>
<p>1.MySQL数据库的底层原理</p>
</blockquote>
<p>MySQL数据库是C/S架构模式，我们关心的是Server端，也就是mysqld这个进程。MySQL服务端是二层架构：<br>1.SQL层(SQL Layer),在MySQL数据库系统处理底层数据之前的所有工作都是在这一层完成，包括权限判断，SQL解析，执行计划优化，查询缓存的处理等等。具体模块及职责如下:</p>
<ul>
<li>初始化模块: MySQL Server启动的时候做初始化操作</li>
<li>核心API: 提供一些非常高效的底层操作功能的优化实现</li>
<li>网络交互模块: 抽象底层网络交互所使用的api，实现底层网络数据的接收与发送</li>
<li>Client&amp;Server交互协议模块: MySQL 客户端和服务端交互的协议实现，基于TCP/IP,Socket等</li>
<li>用户模块: 用户管理模块，包括用户的登录连接权限以及用户的授权管理</li>
<li>访问限制模块: 根据用户模块的授权信息来控制用户对数据的访问</li>
<li>连接管理模块: 负责监听对MySQL Server的各种请求，接收连接请求，转发所有的连接请求到线程管理模块，每一个连接上MySQL Server的客户端请求都会被分配或者创建一个连接线程为其单独服务</li>
<li>Query解析和转发模块: 连接线程接收到客户端的一个Query之后，将Query分类后转发给各个对应的处理模块</li>
<li>Query Cache模块: 将客户端提交给MySQL的Select类Query请求的返回结果集缓存到内存中，与该Query的一个Hash值做一个对应。当取数据的基表发生变化之后，缓存失效</li>
<li>Query 优化器模块: 优化客户端请求的Query，根据一些算法来得出最优的策略，告诉程序如何去取这个Query语句的结果</li>
<li>表变更管理模块: 负责完成DDL、DML的Query，比如update，delete，insert，create table，alter table等语句的处理</li>
<li>表维护模块: 表的状态检查，错误修复</li>
<li>系统状态管理模块: 在客户端请求系统状态的时候，将各种系统状态返回给用户，比如show status,show variables等</li>
<li>表管理器: 维护.frm文件，以及一个Cache,缓存各个表的结构信息。</li>
<li>日志记录模块: 负责的整个系统的日志记录</li>
<li>复制模块: 分为Master模块和Slave模块，Master模块主要负责在Replication环境下读取Master节点的binary日志，以及和Slave端的IO线程交互。Slave模块有两个线程(IO线程和SQL线程)，IO线程从Master请求和接受binary日志，并写入本地relay log。SQL线程从relay log中读取日志事件，解析成可以执行的SQL语句，然后顺序执行，这样子从节点就和主节点的数据基本上保持一致。</li>
<li>存储引擎接口模块: 将各种数据处理高度抽象化，各种存储引擎产品实现接口即可，实现了MySQL特有的可插拔存储引擎。</li>
</ul>
<p>2.存储引擎层(Storage Engine Layer),底层数据的存取都是在这一层做的，常用的存储引擎有InnoDB引擎和MyISAM引擎。</p>
<blockquote>
<p>2.InnoDB引擎和MyISAM引擎的区别和应用场景</p>
</blockquote>
<p>从这两种存储引擎的优缺点来谈区别以及应用场景<br>【InnoDB】<br>优点：支持事务，支持外键<br>缺点：占用磁盘多，读效率慢于MyISAM<br>【MyISAM】<br>优点：查询较快（读取数据不加锁），支持多种存储方式（静态表，压缩表等）<br>缺点：写入较慢（锁表），没有事务。</p>
<p>结论：支持事务选InnoDB,对读有要求的选MyISAM。</p>
<blockquote>
<p>3.数据库索引的原理，分类</p>
</blockquote>
<blockquote>
<p>4.B+树有了解吗？为什么MySQL选用B+树做主要存储结构，为什么常用索引推荐使用B+树？为什么B+树可以减少磁盘IO?</p>
</blockquote>
<blockquote>
<p>4.如何避免索引失效？</p>
</blockquote>
<blockquote>
<p>5.有处理过MySQL优化吗？如何优化？</p>
</blockquote>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="SpringFramework"><a href="#SpringFramework" class="headerlink" title="SpringFramework"></a>SpringFramework</h3><blockquote>
<p>1.简单谈谈Spring的IOC和AOP,都在哪些场景用到过？</p>
</blockquote>
<p>IOC是控制反转，就是对象的创建工作交给Spring容器来做，程序员不需要new出来，需要什么就跟Spring容器要，前提是容器里边有这个对象，底层实现是反射。AOP是面向切面编程，在记录日志，权限控制，事务方面都有应用，底层实现是动态代理。</p>
<blockquote>
<p>2.Spring中Bean生命周期过程，以及两种作用域Singleton和Prototype有什么区别，应用场景有哪些？</p>
</blockquote>
<p>生命周期:<br>1.Bean的建立：有BeanFactory读取Bean定义文件，并生成各个实例</p>
<p>2.Setter注入：执行Bean的属性依赖注入</p>
<p>3.BeanNameAware的setBeanName()：如果Bean实现了org.springframework.beans.factory.BeanNameAware接口，则执行其setBeanName()方法</p>
<p>4.BeanFactoryAware的setBeanFactory()：如果Bean实现了org.springframework.beans.factory.BeanFactoryAware接口，则执行其setBeanFactory()方法</p>
<p>5.BeanPostProcessors的processBeforeInitialization()：容器中如果有实现org.springframework.beans.factory.BeanPostProcessors接口的实例，则任何Bean在初始化之前都会执行这个实例的processBeforeInitializaton()方法</p>
<p>6.InitializingBean的afterPropertiesSet()：如果Bean类实现了org.springframework.beans.factory.InitailizingBean接口，则执行去afterPropertiesSet()方法</p>
<p>7.Bean定义文件中定义init-method：如果在xml文件中定义一个Bean的时候指定了init-methond，则执行这个方法，并且这个初始化方法是不能带有参数。</p>
<p>8.BeanPostProcessors的processAfterInitializaton()：容器中如果有实现org.springframework.beans.factory.BeanPostProcessors接口的实例，则去执行processAfterInitialization()方法</p>
<p>9.DisposableBean的destroy()方法：在容器关闭时，如果Bean实现了org.springframework.beans.factory.DisposableBean接口，则执行它的destroy()方法</p>
<p>10.Bean定义文件中定义destroy-method：在容器关闭时，执行destroy-method()方法，并且这个方法是不带参数的</p>
<p>作用域：<br>【singleton】：单例，每次访问都是返回同一个实例，Spring默认，无状态的Bean都应该使用Singleton，比如需要回收的重要资源(数据库连接池，线程池)<br>【prototype】：多例，每次访问都会进行new操作，Spring不会对Bean的整个生命周期进行负责，具有prototype的作用域的Bean创建后交由调用者负责销毁对象回收资源，有状态的Bean应该配置成prototype</p>
<blockquote>
<p>3.AOP动态代理模式的两种类型,区别是什么？</p>
</blockquote>
<p>AOP动态代理有两种：JDK代理和CGLIB代理，JDK代理只能对实现了接口的类进行代理，而不能针对未实现接口的类。CGLIB代理是针对类(未使用final修饰)实现代理,主要是对指定的类生成一个子类，覆盖其中的方法，底层是使用ASM字节码生成框架，使用字节码技术生成代理类。<br>Spring是怎么选择使用哪种代理的呢？如果一个Bean实现了接口，那么默认使用JDK代理，当Bean没有实现接口时，Spring默认使用CGLIB代理。</p>
<blockquote>
<p>4.Spring事务的特性，隔离级别，传播行为</p>
</blockquote>
<p>特性：<br>1.原子性(Atomicity)： 事务的不可分割性<br>2.一致性(Consistency)：事务执行前后数据的完整性保持一致<br>3.隔离性(Isolation)：事务执行过程中，不应该受到其他事务的干扰<br>4.持久性(Durability)：事务一旦结束，数据就持久到数据库</p>
<p>如果事务不考虑隔离性，就会引发安全性问题。比如：<br>1.脏读：一个事务读到了另一个事务未提交的数据<br>2.不可重复读：一个事务读到了另一个事务已经提交的update数据导致多次查询结果不一致<br>3.虚幻读：一个事务读到了另一个事务已经提交的insert的数据导致多次查询结果不一致</p>
<p>为了解决这个问题，引出事务隔离级别：<br>1.默认(default)：默认的隔离级别，使用数据库的默认隔离级别<br>2.未提交读(read uncommited)：脏读，不可重复读，虚幻读都有可能发生<br>3.已提交读(read commited)：避免脏读，但是不可重复读和虚幻读还是有可能发生<br>4.可重复读(repeatable read)：避免脏读和不可重复读，但是虚幻读还是有可能发生<br>5.串行化(Serializable)：避免上述所有读问题</p>
<p>MySQL默认的隔离级别是可重复读，Oracle默认的隔离级别是已提交读</p>
<p>事务的传播行为：<br>1.保证同一个事务中<br>PROPAGATION_REQUIRED：支持当前事务，如果不存在就新建一个<br>PROPAGATION_SUPPORTS：支持当前事务，如果不存在，就不使用事务<br>PROPAGATION_MANDATORY：支持当前事务，如果不存在就抛异常<br>2.保证没有在同一个事务中<br>PROPAGATION_REQUIRED_NEW：如果有事务存在，挂起当前事务，创建一个新的事务<br>PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务<br>PROPAGATION_NEVER：已非事务方式运行，如果有事务存在，则抛出异常<br>PROPAGATION_NESTED：如果当前事务存在，则已嵌套事务执行</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><blockquote>
<p>1.SpringMVC的作用，与Struct的区别是什么？</p>
</blockquote>
<p>SpringMVC是一个基于请求驱动的Web框架，使用了前端控制器模式来设计，再根据请求映射规则分发给相应的页面控制器进行处理。简单点就是处理http请求和响应。<br>区别：</p>
<ul>
<li>SpringMVC是基于Servlet来实现，Struct是基于Filter来实现的。</li>
<li>SpringMVC是基于方法级别的拦截，一个方法对应一个request上下文，Controller Bean默认是sigleton的，只会创建一个Controller，但是没有共享的属性，所以是线程安全。Struct是基于类级别的拦截，每次请求都会创建一个Action，Action Bean在Spring容器中是prototype的，通过setter方法将request注入到属性当中。</li>
</ul>
<blockquote>
<p>2.SpringMVC的工作原理，都涉及到哪些类？</p>
</blockquote>
<p>1.用户发送请求至前端控制器DispatherServlet</p>
<p>2.DispatherServlet接收到请求之后调用HandlerMapping处理映射器</p>
<p>3.处理映射器找到具体的处理类(xml配置，注解)，生成处理器对象及处理拦截器一并返回给<br>DispatherServlet</p>
<p>4.DispatherServlet调用HandlerAdapter处理适配器</p>
<p>5.HandlerAdapter经过适配调用具体的处理器(Controller)</p>
<p>6.Controller执行完成返回ModelAndView对象</p>
<p>7.HandlerAdapter将ModelAndView返回给DispatherServlet</p>
<p>8.DispatherServlet将ModelAndView对象返回给ViewResolver视图解析器</p>
<p>9.ViewResolver解析后返回具体的View</p>
<p>10.DispatherServlet根据View进行渲染视图</p>
<p>11.DispatherServlet响应用户</p>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><blockquote>
<p>1.Mybatis有什么优缺点</p>
</blockquote>
<p>【优点】<br>1.基于SQL编程，SQL写在XML里边，与程序解耦，对JDBC做了进一步的封装，消除JDBC大量冗余的代码。<br>2.与Spring有很好的集成<br>3.提供映射标签，支持对象与数据库的ORM字段关系映射，提供对象关系映射标签，支持对象关系组件维护<br>【缺点】<br>1.SQL语句工作量大，尤其是字段多或者关联表多的时候。<br>2.SQL依赖于数据库，不能随意更换数据库</p>
<p>适用场景：<br>专注于SQL，提供足够灵活的DAO解决方案<br>对性能有要求或者需求变化比较多的项目</p>
<blockquote>
<p>2.#{}和${}的区别</p>
</blockquote>
<p>#{}是预编译处理，\${}是字符串替换<br>Mybatis在处理#{}时，会将SQL中的#{}替换为?,调用PrepareStatement的set()方法来赋值，所以，#{}可以有效的防止SQL注入。处理\${}时，就是把\${}替换成变量的值。</p>
<blockquote>
<p>3.实体类中的属性名和表中的字段名不一样你怎么处理？</p>
</blockquote>
<p>两种方案<br>（1）resultType是实体类，查询SQL语句中定义字段名的别名，让字段名的别名和实体类属性名一致。<br>（2）resultMap映射，将字段名和属性名的一一对应起来</p>
<blockquote>
<p>4.模糊查询like怎么写？</p>
</blockquote>
<p>两种写法<br> (1) 在Java代码中添加sql通配符%号<br> (2) 在SQL语句中拼接通配符，会引起SQL注入，不推荐</p>
<blockquote>
<p>5.通常一个xml映射文件都会与一个Mapper接口相对应，讲一下Mapper接口的工作原理，还有Mapper接口里的方法可以重载吗？</p>
</blockquote>
<p>Mapper接口的全限名，就是xml文件中的namespace值，Mapper接口中的方法名，就是xml中MappedStatement中的id值，Mapper接口中方法的参数，就是传递给SQL的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名可以唯一定位一个MappedStatement。</p>
<p>Mapper接口中方法是不能重载的，因为是通过全限名+方法名来保存和寻找MappedStatement的。</p>
<p>Mapper接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理Proxy对象，代理对象Proxy会拦截接口方法，转而执行MappedStatement所代表的SQL，然后将SQL执行结果返回。</p>
<blockquote>
<p>6.Mybatis是如何进行分页的？分页插件的原理是什么？</p>
</blockquote>
<p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL，然后重写SQL，根据direct方言，添加对应的物理分页语句和物理分页参数。</p>
<blockquote>
<p>7.Mybatis如何实现一对一查询？</p>
</blockquote>
<p>连表查询，只查询一次，通过在resultMap里边配置association节点配置一对一的类就可以完成。</p>
<blockquote>
<p>8.Mybatis如何实现一对多查询？</p>
</blockquote>
<p>连表查询，只查询一次，通过在resultMap里边配置collection节点配置一对多的类就可以完成。</p>
<blockquote>
<p>9.Mybatis是否支持延迟加载，如果支持，实现原理是什么？</p>
</blockquote>
<p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的是一对一，collection指的是的一对多，在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnable=true|false</p>
<p>实现原理是使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的SQL，把B查询出来，然后调用a.setB(b)，这样子a.getB()就有值了，接着完成a.getB().getName()方法的调用，这就是延迟加载的原理。</p>
<blockquote>
<p>10.Mybatis的一级缓存和二级缓存</p>
</blockquote>
<p>一级缓存，基于PrepetualCache的HashMap本地缓存，其存储作用域为本地Session，当Session flush或者close之后，该Session中的所有Cache就将清空，默认打开一级缓存。</p>
<p>二级缓存，默认也是采用PrepetualCache的HashMap缓存，不用在于其存储作用域为Mapper,或者说是namespace，并且可以自定义存储源，比如Ehcache，默认二级缓存是不开启的，要开启二级缓存，使用二级缓存属性类需要实现序列化接口，在映射文件中配置<cache></cache></p>
<blockquote>
<p>11.接口是如何绑定的？</p>
</blockquote>
<p>接口绑定有两种方式，一种是通过注解绑定，一种是通过xml绑定。<br>注解绑定就是在接口的方法上面加上@Select,@Update等注解，注解里边写SQL语句。<br>xml绑定就是xml里边用特定的标签来写SQL语句,通过namespace+id来绑定。</p>
<blockquote>
<p>12.使用Mybatis的Mapper接口调用时有哪些要求？</p>
</blockquote>
<p>（1）xml中namespace即接口的全限名<br>（2）Mapper接口方法名和xml中定义的每个SQL的id相同<br>（3）Mapper接口方法的输入参数类型和xml中定义的SQL的parameterType的类型相同<br>（4）Mapper接口方法的输出参数类型和xml中定义的SQL的resultType的类型相同</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><blockquote>
<p>1.为什么使用消息队列？</p>
</blockquote>
<p>消息队列最主要的三个应用场景:解耦、异步、削峰。</p>
<p>引入消息中间件进行系统解耦，一般使用订阅模式，强耦合的系统通过发布消息到消息队列中，其他系统通过订阅模式来获取消息之后触发来处理业务逻辑，从而实现系统间的解耦，不至于要对接一个新的系统的又要改代码，解耦非常有用，也是很重要的。</p>
<p>再来说说异步，一些非必要的业务逻辑以同步的方式运行，非常耗时间，特别是调用链很长的时候，不需要同步的等待其他系统调用返回，改进用户体验，类似于单体系统中的线程。</p>
<p>最后再来说说削峰，我们做的系统的几乎没有什么并发量，但是我可以说说这块的理解，当并发量大的时候，大量的请求涌向数据库连接池，连接池处理不了那么多，只能不断的报数据库连接异常，大量的请求累计会把系统搞垮，这时候就需要消息中间件来的削峰，所有的请求都进入消息队列，然后系统再从队列里按照自己能处理的并发量慢慢拉取消息来处理，这样子就把大并发压力转移到消息队列中间件。</p>
<blockquote>
<p>2.使用消息队列的缺点</p>
</blockquote>
<p>引入了消息队列这种技术就要知道缺点是什么，能不能cover住这个技术，不然那就是给自己挖坑。</p>
<p>原本的系统运行的好好的，现在你引入了一个中间件，如果中间件挂了，那你的系统是不是就没法正常运行了，这将会给公司带来直接的经济损失，系统的可用性降低。</p>
<p>系统的复杂性增加，引入了消息中间件，要考虑很多方面的问题，比如一致性问题，如何保证消息不被重复消费，如何保证消息的可靠传输等等。</p>
<p>这两个问题都直接涉及到MQ的选型问题。</p>
<blockquote>
<p>3.那么多种mq，为什么选择这种，怎么做的技术选型？</p>
</blockquote>
<p>技术选型这个该怎么说呢？虽然还轮不到咱，但是我们自己也要懂，总有一天会轮到我们的。做技术选型首先就是要了解都有哪些主流的产品，都有什么优缺点，如果出现了问题我们自己是否能cover住，即使不能，社区会不会解决？活跃度怎么样，这些都是需要了解比较的，然后选出一个能够满足业务前提下的最优的一种产品。</p>
<p>ActiveMQ, Java语言开发，单机吞吐量万级，延时ms级，主从架构，可用性高，产品成熟，文档全面。社区活跃度低。<br>RabbitMQ, Erlang语言开发，单机吞吐量万级，延时us级，主从架构，可用性高，并发能力很强，性能及其好，延时很低，管理界面较丰富，社区活跃度高。<br>RocketMQ, Java语言开发，单机吞吐量10万级，延时ms级，分布式架构，可用性非常高，MQ功能完备，扩展性级佳,阿里出品，微众银行也有一个分支，质量值得信赖。<br>Kafka, Scala语言开发，单机吞吐量10万级，延时ms级，分布式架构，可用性非常高，只支持MQ的主要功能，像消息查询，回溯等功能未提供，因为其主要应用场景是大数据领域而非MQ。</p>
<p>综上，可以根据业务场景和团队能力进行技术选型。比如Java小团队，吞吐量不是很大，可以优先选择RabbitMQ，Java中大型团队可以考虑RocketMQ来进行改造，挑战更高的性能。如果是日志采集或者大数据方面的场景，当然要选Kafka了。</p>
<blockquote>
<p>4.如何保证消息不被重复消费？或者说如何保证消息队列的幂等性？</p>
</blockquote>
<p>什么时候会造成消息重复消费呢？我没有遇到过这种情况，我觉得可能是网络原因造成，正常情况下，消费者在消费完消息后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除，像RabbitMQ会发送一个ACK确认信息，如果确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息发给其他的消费者。</p>
<p>如果拿到这个消息来做数据库的插入操作，那就给这个消息做一个主键操作，这样子即使重复消费了也会导致主键冲突，避免数据库出现脏数据。</p>
<p>如果拿到这个消息之后是放到redis里边，那同样也是不需要解决的，redis的set操作就是幂等操作。</p>
<p>如果还不行，可以借助第三方来做一个消费记录，可以是redis，给消息分配一个全局唯一id，只要消费过该消息，将&lt;id,message&gt;写入redis，消费者在开始消费前，先去redis中查询有没有消费记录即可。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><blockquote>
<p>1.谈谈TCP/IP模型</p>
</blockquote>
<p>这个问题可以从OSI七层模型谈起引出TCP/IP五层模型，OSI是学术定义，但是不实用，工业界使用的是TCP/IP。<br>OSI七层模型:</p>
<ul>
<li>应用层 针对特定的协议，为应用程序做服务,比如SMP,POP3,SSH,FTP等协议。</li>
<li>表示层 负责数据格式的转换，把不同表现形式的信息转换成适合网络传输的格式。</li>
<li>会话层 负责建立和断开通信连接，什么时候建立连接，什么时候断开连接以及保持多久的连接。</li>
<li>传输层 在两个通信节点之间负责数据的传输，起着可靠传输的作用。(运行在这一层的设备有四层交换机，四层路由器)</li>
<li>网络层 路由选择，在多个网络之间转发数据包，负责将数据包传送到目的地址。(运行在这一层的设备有路由器，三层交换机)</li>
<li>数据链路层 负责物理层面互联设备之间的通信传输，比如一个以太网相连的两个节点之间的通信，是数据帧与1、0比特流之间的转换。(运行在这一层的设备是网桥、以太网交换机、网卡)</li>
<li>物理层 主要是1、0比特流与电子信号的高低电平之间的转换。(运行在这一层的设备是中继器、双绞线)</li>
</ul>
<p>TCP/IP五层模型:<br>七层模型中的应用层、表示层、会话层在这个模型中都属于应用层，其他四层不变。</p>
<blockquote>
<p>2.TCP的三次握手和四次挥手，为什么要这样子设计？</p>
</blockquote>
<p>【三次握手】<br>1.客户端发起连接请求，发送SYN=1和客户端序号c给服务器端，同时进入SYN_SENT状态。<br>2.服务端收到SYN后需要作出确认，于是发送ACK=1,同时自己也发送SYN=1,服务端序号s，同时发送确认号c+1(表示下一个接受序号),进入SYN_RCVD状态。<br>3.客户端收到服务端的SYN和ACK,作出确认，发送ACK=1，以及序号c+1的数据，同时发送确认号s+1(表示客户端下一个要接收的序号)。此时客户端和服务端进入ESTABLISHED状态，确认过眼神，状态已经建立。</p>
<p>【四次挥手】<br>1.客户端发起断开请求，发送FIN=1和序号c给服务端，客户端进入FIN-WAIT-1状态。<br>2.服务端收到FIN后作出确认，发送ACK=1和服务端序号s,确认号c+1(表示下一个接收序号),服务端此时还可以向客户端发送数据,服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。<br>3.服务端没有数据发送时，它向客户端发送FIN=1,ACK=1,请求断开连接，同时发送服务端序号s，确认号c+1,服务端进入LAST-ACK状态。<br>4.客户端收到之后进行确认，发送ACK=1,以及序号c+1和确认号s+1。客户端进入TIME-WAIT状态，客户端需要等待2MSL,确保服务端收到了ACK，若这期间没有服务端的消息，便可认为服务端收到了确认，此时可以断开连接。服务端和客户端进入CLOSED状态。</p>
<p><img src="/asset/img/interview-summary/tcp_shake_hand.jpg" alt="TCP三次握手四次挥手"></p>
<p>为什么这样子设计呢？握手两次行不行？</p>
<p>两次握手的话，只要服务端发出确认就建立连接了。有一种情况是客户端发出了两次连接请求，但由于某种原因，使得第一次请求被滞留了。第二次请求先到达后建立连接成功，此后第一次请求终于到达，这是一个失效的请求了，服务端以为这是一个新的请求于是同意建立连接，但是此时客户端不搭理服务端，服务端一直处于等待状态，这样就浪费了资源。假设采用三次握手，由于服务端还需要等待客户端的确认，若客户端没有确认，服务端就可以认为客户端没有想要建立连接的意思，于是这次连接不会生效。</p>
<p>四次握手，为什么客户端发送确认后还需要等待2MSL?</p>
<p>因为第四次握手客户端发送ACK确认后，有可能丢包了，导致服务端没有收到，服务端就会再次发送FIN = 1，如果客户端不等待立即CLOSED，客户端就不能对服务端的FIN = 1进行确认。等待的目的就是为了能在服务端再次发送FIN = 1时候能进行确认。如果在2MSL内客户端都没有收到服务端的任何消息，便认为服务端收到了确认。此时可以结束TCP连接。</p>
<blockquote>
<p>3.有了传输层为什么还要网络层？</p>
</blockquote>
<p>网络层是针对主机与主机之间的服务。而传输层针对的是不同主机进程之间的通信。网络层负责将数据包从源IP地址转发到目标IP地址，而传输层负责将数据包再递交给主机中对应端口的进程。</p>
<blockquote>
<p>4.TCP序号的作用，怎么样保证可靠传输？</p>
</blockquote>
<p>序号和确认号是实现可靠传输的关键。<br>序号-当前数据包的首个字节的顺序号，确认号-表示下一个想要接收的字节序号，并且已经正确收到确认号之前的所有字节。<br>通信双方通过序号和确认号来判断数据是否丢失，是否按顺序到达，是否冗余等等，如果丢失了就重传，如果冗余了就丢弃，换句话说，序号，确认号和重传机制保证了数据不丢失、不重复。</p>
<blockquote>
<p>5.TCP和UDP的区别</p>
</blockquote>
<ul>
<li>TCP面向连接，传输数据之前需要建立会话，UDP是无连接的</li>
<li>TCP是可靠传输，UDP只负责发送数据，不保证接收方是否接收，不保证可靠</li>
<li>TCP面向字节流，UDP面向报文</li>
<li>TCP只支持点到点通信，UDP支持点到点、点到面、面到面的通信</li>
</ul>
<blockquote>
<p>6.浏览器的一个HTTP请求到后端的一个大致过程是怎样的？</p>
</blockquote>
<p>1.利用DNS进行域名解析(先找本地hosts再找运营商的DNS服务器)<br>2.发起TCP三次握手<br>3.建立TCP连接之后发起HTTP请求<br>4.服务器响应HTTP请求，浏览器得到HTML代码<br>5.浏览器解析HTML代码，并请求HTML代码中的资源(csc,js,image)<br>6.浏览器对页面进行渲染</p>
<blockquote>
<p>7.HTTP是基于TCP还是UDP?</p>
</blockquote>
<p>HTTP 1.0/1.1 是基于TCP协议，客户端向服务端发送一个HTTP请求时，需要与服务端建立TCP连接，三次握手成功后才会进行数据交互，目前基本上都是HTTP 1.1的。2.0是基于UDP的。</p>
<blockquote>
<p>8.HTTP请求和响应的报文结构</p>
</blockquote>
<p>HTTP请求报文结构：</p>
<ul>
<li>请求头：包括请求方法、URL、HTTP协议版本号</li>
<li>请求头： 多组键值对</li>
<li>请求空行：告诉服务器请求头的键值对已经发送完毕</li>
<li>请求主体</li>
</ul>
<p>HTTP响应报文结构：</p>
<ul>
<li>响应行：包括HTTP协议版本号、状态码、状态码描述</li>
<li>响应头：多组键值对</li>
<li>响应空行：告诉客户端响应头键值对结束</li>
<li>响应主体</li>
</ul>
<blockquote>
<p>9.HTTP常见的状态码</p>
</blockquote>
<ul>
<li>1xx：信息性状态码，表示接收的请求正在处理</li>
<li>2xx：成功状态码，表示请求处理完毕</li>
<li>3xx：重定向状态码，表示需要进行附加操作以完成请求</li>
<li>4xx：客户端错误状态码，表示服务器无法处理请求</li>
<li>5xx：服务端错误状态码，表示服务器处理请求出错</li>
</ul>
<p>常见的状态码有：</p>
<ul>
<li>200 OK,请求被正常处理</li>
<li>201 created，对象创建成功</li>
<li>301 Move Permanently，永久性重定向</li>
<li>302 Found，临时重定向</li>
<li>400 Bad Request，请求报文中格式不对</li>
<li>403 Forbidden，对请求的资源没有权限访问</li>
<li>404 Not Found，在服务器上找不到请求资源</li>
<li>405 Method Not Allowed，请求方法不允许</li>
<li>500 Internal Server Error，服务器内部错误</li>
</ul>
<blockquote>
<p>10.GET和POST区别</p>
</blockquote>
<ul>
<li>GET用于获取数据，POST用于提交数据</li>
<li>GET的参数长度有限制，POST没有限制</li>
<li>GET把参数放在url中，POST通过封装参数到请求体中发送</li>
<li>GET请求只能进行url编码，POST支持多种编码方式</li>
<li>GET比POST参数更不安全，因为参数暴露在url上，所以不能用来传递敏感信息</li>
<li>GET具有幂等性，多次请求得到的结果一样，POST不具备幂等性，多次请求会有重复提交问题</li>
<li>GET请求会被浏览器保存为历史记录，POST请求不能</li>
<li>GET请求产生一个TCP数据包，POST产生两个TCP数据包<br>对于GET请求方式，浏览器会把header和data一起发送出去，服务器接收请求返回数据<br>对于POST请求方式，浏览器先发送header，服务器响应100继续，浏览器在发送data，服务器接收请求返回数据</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>1.常见的排序算法</p>
</blockquote>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/12/18/interview-summary/">Java后端面试题整理</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Ryan</a></p>
        <p><span>发布时间:</span>2018-12-18, 21:47:55</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/12/18/interview-summary/" title="Java后端面试题整理">https://ruanzz.github.io/2018/12/18/interview-summary/</a>
            <span class="copy-path" data-clipboard-text="原文: https://ruanzz.github.io/2018/12/18/interview-summary/　　作者: Ryan" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/12/22/talk-nginx/">
                    高性能Nginx(一)
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/12/15/talk-recent/">
                    职场系列(一)
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java基础"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语法糖"><span class="toc-number">1.1.</span> <span class="toc-text">语法糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-number">1.2.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-number">1.3.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO"><span class="toc-number">1.4.</span> <span class="toc-text">IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">1.5.</span> <span class="toc-text">JVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库"><span class="toc-number">2.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL"><span class="toc-number">2.1.</span> <span class="toc-text">MySQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架"><span class="toc-number">3.</span> <span class="toc-text">框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringFramework"><span class="toc-number">3.1.</span> <span class="toc-text">SpringFramework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC"><span class="toc-number">3.2.</span> <span class="toc-text">SpringMVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis"><span class="toc-number">3.3.</span> <span class="toc-text">Mybatis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中间件"><span class="toc-number">4.</span> <span class="toc-text">中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MQ"><span class="toc-number">4.1.</span> <span class="toc-text">MQ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机网络"><span class="toc-number">5.</span> <span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">6.</span> <span class="toc-text">算法</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <!-- <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a> -->
            <!-- <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a> -->
            <!-- <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a> -->
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <!-- <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a> -->
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Java后端面试题整理　| Ryan's Blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/12/22/talk-nginx/" title="上一篇: 高性能Nginx(一)">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/12/15/talk-recent/" title="下一篇: 职场系列(一)">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/kubernetes/">Kubernetes</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/01/rabbitmq/">RabbitMQ</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/31/restful/">RESTful API</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/24/office-skill/">职场系列(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/06/mysql-optimize/">MySQL优化思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/26/cloud-compute/">谈谈云</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/flag/">Flag</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/22/talk-nginx/">高性能Nginx(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/18/interview-summary/">Java后端面试题整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/talk-recent/">职场系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/03/hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018-2019 Ryan
            </div>
            <!-- <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div> -->
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>