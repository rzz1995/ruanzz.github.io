<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes</title>
      <link href="/2019/04/07/kubernetes/"/>
      <url>/2019/04/07/kubernetes/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes是Google开源的容器编排引擎，是Google内部Borg系统的开源版本，是现在十分火热的技术，堪比之前的Hadoop和OpenStack。源代码开源在Github，是CNCF云原生基金会的第一个毕业项目，开启了云原生时代。本文是Kubernetes的入门。<br><a id="more"></a></p><p>Kubernetes简称k8s，k和s中间有8个单词所以简称k8s，Kubernetes采用Go语言开发，一般Kubernetes使用的容器技术有Docker或者rkt，Docker也是Go语言开发的，而且更加有意思的是Go语言本身也是用Go来写的，Go目前在云计算、中间件、区块链等领域疯狂的攻城略地,可以预见在不久的将来，Go将会成为主流语言。</p><p>在正式进入Kubernetes之前，首先得来了解一下Docker，Docker目前是很多公司都拥抱的技术，可以在开发、测试、运维阶段都保证环境一致，并且很容易通过编排引擎来调度容器，这个是后话。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一种轻量级的虚拟化技术，是在操作系统级别虚拟化，各个容器之间共享操作系统资源，每个容器都是操作系统的一个进程，通过CGroup和NameSpace技术来达到资源的限制以及隔离，和虚拟机相比，隔离的不是很彻底，所以安全性一直被诟病，但是这个不影响它的欢迎程度，基本的计算、存储、网络资源隔离都是不错的，并且启动一个容器是秒级的，虚拟机是分钟级，所以容器可以在秒级别进行动态扩容和释放，这个和云最初的设想完全吻合，也是容器大受欢迎的原因。</p><p>我的环境是OS X系统，可以直接通过<code>brew cask install docker</code>来安装Docker，其他的平台可以参考官方文档来安装，Docker是C/S架构，安装完成之后命令行客户端就完成了，启动服务端之后就可以通过客户端来与后台的dockerd进程来通信了。客户端的话是通过<code>docker</code>命令进行交互，与服务端通信也是通过的客户端发送命令，然后由客户端与服务端进行通信，通过命令<code>docker info</code>可以查看Docker服务端的信息。</p><p>Docker主要是三大块的内容:容器，镜像，仓库，这三个最主要的是镜像，其他两个跟镜像有关，像仓库就是存储镜像的地方，容器是从镜像来启动的，镜像也是我们开发人员来重点关注和维护的，之前我们的打包出来给运维人员是一个jar包或者war包，现在我们打包出来的是镜像，直接push到我们内部搭建的仓库中，测试和运维直接从仓库中拉取镜像来启动容器即可，这就保证了开发，测试，运维的环境一致。</p><p>镜像的构建由开发人员来维护，构建Docker镜像需要Dockerfile文件，这个就是构建Docker镜像的描述文件，这里边有一系列的语法，这里不做赘述，下面我们来看一下Dockerfile.<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> daocloud.io/nginx</span><br><span class="line"><span class="keyword">COPY</span> html/* /usr/share/nginx/html</span><br></pre></td></tr></table></figure></p><p>第一行是<code>FROM</code>开头，表示从哪个镜像开始构建，这里是以<code>daocloud.io/nginx</code>为原始镜像，第二行是<code>COPY</code>拷贝<code>html</code>这个文件夹的文件到原始镜像的html文件夹中，这样子就会新构建了一层镜像，这就要求在Dockerfile同级目录下有一个html文件夹，html文件夹下有一个文件index.html。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  html more index.html </span><br><span class="line">&lt;h1&gt;Hello Docker&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>接下来我们使用<code>docker build -t nginx-demo .</code> 来构建镜像，镜像名为<code>nginx-demo</code> ，<code>.</code>代表的是构建的上下文环境，这样子就可以直接找到html文件夹，一般这个上下文环境只要包含我们必须的文件，不然构建镜像会相当的慢。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  demo docker build -t nginx-demo .</span><br><span class="line">Sending build context to Docker daemon  3.584kB</span><br><span class="line">Step 1/2 : FROM daocloud.io/nginx</span><br><span class="line">latest: Pulling from nginx</span><br><span class="line">Digest: sha256:dabecc7dece2fff98fb00add2f0b525b7cd4a2cacddcc27ea4a15a7922ea47ea</span><br><span class="line">Status: Downloaded newer image for daocloud.io/nginx:latest</span><br><span class="line"><span class="meta"> ---&gt;</span> 2bcb04bdb83f</span><br><span class="line">Step 2/2 : COPY html/* /usr/share/nginx/html</span><br><span class="line"><span class="meta"> ---&gt;</span> 2289cd357a0e</span><br><span class="line">Successfully built 2289cd357a0e</span><br><span class="line">Successfully tagged nginx-demo:latest</span><br></pre></td></tr></table></figure></p><p>这是构建的过程，非常的清晰，每一步都会生成一层镜像，第一步就是拉镜像，生成第一次层，id为2bcb04bdb83f，第二步是拷贝，生成第二层，id为2289cd357a0e，最后生成了镜像nginx-demo:latest，如果没有指定镜像标签的，默认的是latest，实际开发中一般是要指定tag的，tag就是对应的版本。好了，我们通过命令<code>docker image ls</code>来查看一下镜像信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  demo docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx-demo          latest              2289cd357a0e        5 minutes ago       109MB</span><br><span class="line">daocloud.io/nginx   latest              2bcb04bdb83f        11 days ago</span><br></pre></td></tr></table></figure></p><p>接下来就是启动容器<code>docker run --name nginx-80 -d -p 8080:80 nginx-demo</code>,指定容器名称为nginx-80，<code>-d</code>是指后台运行，<code>-p</code>指的是端口映射，将Docker Host的8080端口映射到容器的80端口，<code>nginx-demo</code>是镜像名，即这个容器是通过<code>nginx-demo</code>这个镜像来启动的。启动成功之后命令返回的是容器的长id，然后我们通过访问nginx来看看效果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  demo curl http://127.0.0.1:8080</span><br><span class="line">&lt;h1&gt;Hello Docker&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>好了，Docker我们暂时就说到这了，Docker本身是一个相对底层的容器引擎，和KVM，Xen这种属于同一级别的东西，现实中我们不可能直接这样子操作，像KVM有一个OpenStack云平台来管理操作，那是正常人使用的东西，像这种用命令行一个一个启动容器的对用户不太友好，而且调度也不方便。所以我们来看看今天的主角Kubernetes。</p><h2 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h2><p>先从大的方面来了解一下Kubernetes，Kubernetes集群包含一个master节点和多个node节点，master是控制集群的中心，运行有多个服务，包括面向用户的API Server,负责维护集群状态的Controller Manager，负责调度任务的Scheduler。node是提供CPU，内存和存储资源的节点，每个node节点运行这kubelet和kube-proxy，kubelet是一个agent客户端，负责维护node节点的运行状态以及和master进行通信，kube-proxy主要是实现集群网络服务。</p><p>这个可以从Kubernetes的官方网站去了解，而且官方文档的还有一个特别棒的就是可以实时交互一个k8s集群，这样子就可以一边看Tutorial文档，一边实际操作，跟着文档做一遍下来就会对Kubernetes比较清晰了，这里要赞一下官方文档，真的写的很清晰，我的渣渣英语水平都可以很顺畅看完整个Tutorial。</p><h2 id="搭建Kubernetes集群"><a href="#搭建Kubernetes集群" class="headerlink" title="搭建Kubernetes集群"></a>搭建Kubernetes集群</h2><p>我们这里不是真实的生产环境，真实的生产环境搭建还是根据官方文档来参考搭建，我们是试验一个东西，官方文档推荐使用Minikub来搭建一个单节点的集群来做开发测试，当然，如果资源足够的话还是搭建一个完整的真实集群。</p><p>先来安装客户端kubectl，这个可以跟Kubernetes集群通信,还有Minikube也一起安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install kubectl</span><br><span class="line">brew cask install minikube</span><br></pre></td></tr></table></figure></p><p>安装完成之后我们来安装一个单节点的k8s集群，使用VirtualBox来做虚拟层。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --vm-driver virtualbox</span><br></pre></td></tr></table></figure></p><p>运行命令之后我们打开VirtualBox看到已经自动创建了一台虚拟机，并且开始安装相关的服务，因为这个是单节点，master和node都是它，所以服务还是有点多的，等待的时间会比较长，如果安装失败了，删掉再重来即可，运行命令<code>minikube delete</code>会把虚拟机删掉重新，然后再重新安装，生成新的虚拟机来安装即可。</p><p>安装完成之后minikube会自动配置kubectl，把它指向k8s的API服务，运行命令<code>kubectl config current-context</code>查看<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  html kubectl config current-context</span><br><span class="line">minikube</span><br></pre></td></tr></table></figure></p><p>这样子我们就可以使用kubectl和k8s集群通信了，安装好了集群之后我们可以通过命令<code>minikube start</code>和<code>minikube stop</code>来启动和停止集群。还要k8s提供了UI界面，通过命令<code>minikube dashboard</code>来打开，这样子就可以通过页面来操作编排了，但是作为一个开发人员，还是通过命令来和k8s集群通信比较舒服，下面我们就通过命令行来操作编排。</p><h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>在部署之前，我们先将本地Docker客户端和k8s主机的Docker Host的服务端建立联系，运行命令<br><code>eval $(minikube docker-env)</code>,这样子就可以将二者关联起来，关联起来主要是是想构建镜像，模拟开发中的滚动的发布，这个实际开发中一般是通过的Jenkins来触发，我们为了简单就直接手动触发了。</p><p>之前我们已经构建过镜像，不过是在本地，现在本地的docker客户端已经连到了k8s的Docker Host，这个时候是没有刚才我们构建的镜像，通过命令<code>docker build -t k8s-demo:0.1 .</code>构建，构建完成了再通过命令<code>docker image ls</code>可以看到<code>k8s-demo</code>这个镜像，tag是0.1。</p><p>一般我们开发人员会写一个deployment.yml,描述如何进行部署<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: </span><br><span class="line"> name: k8s-demo-deployment</span><br><span class="line">spec:</span><br><span class="line"> replicas: 3</span><br><span class="line"> template:</span><br><span class="line">  metadata:</span><br><span class="line">   labels:</span><br><span class="line">    app: k8s-demo</span><br><span class="line">  spec:</span><br><span class="line">   containers:</span><br><span class="line">    - name: k8s-demo-pod</span><br><span class="line">      image: k8s-demo:0.1</span><br><span class="line">      ports:</span><br><span class="line">       - containerPort: 80</span><br></pre></td></tr></table></figure></p><p>这里边定义了部署的副本数是3个，每个部署都是一个pod，什么是pod？pod是k8s最小的资源调度单位，一般由多个container组成，这些container共享资源，还定义了container的相关信息，包括名称，使用的镜像以及容器端口。这样子我们通过命令来应用部署<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl create -f deployment.yml </span><br><span class="line">deployment.extensions/k8s-demo-deployment created</span><br></pre></td></tr></table></figure></p><p>通过命令<code>kubectl get rs</code>来查看<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl get rs                  </span><br><span class="line">NAME                             DESIRED   CURRENT   READY   AGE</span><br><span class="line">k8s-demo-deployment-774878f86f   3         3         3       5m</span><br></pre></td></tr></table></figure></p><p>然后查看pod相关信息，发现确实是3份<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl get pods</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-demo-deployment-774878f86f-ct8hj   1/1     Running   0          6m</span><br><span class="line">k8s-demo-deployment-774878f86f-gxrp7   1/1     Running   0          6m</span><br><span class="line">k8s-demo-deployment-774878f86f-v77hl   1/1     Running   0          6m</span><br></pre></td></tr></table></figure></p><p>Kubernetes会一直帮我们维护pod的数量为3，我们假设其中的一个pod挂了，看看会不会k8s会不会立即启动一个pod<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl get pods</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-demo-deployment-774878f86f-ct8hj   1/1     Running   0          6m</span><br><span class="line">k8s-demo-deployment-774878f86f-gxrp7   1/1     Running   0          6m</span><br><span class="line">k8s-demo-deployment-774878f86f-v77hl   1/1     Running   0          6m</span><br><span class="line">➜  k8s kubectl delete pod k8s-demo-deployment-774878f86f-ct8hj</span><br><span class="line">pod "k8s-demo-deployment-774878f86f-ct8hj" deleted</span><br><span class="line">➜  k8s kubectl get pods</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-demo-deployment-774878f86f-gxrp7   1/1     Running   0          8m</span><br><span class="line">k8s-demo-deployment-774878f86f-kfhm7   1/1     Running   0          16s</span><br><span class="line">k8s-demo-deployment-774878f86f-v77hl   1/1     Running   0          8m</span><br></pre></td></tr></table></figure></p><p>我们手动删了<code>k8s-demo-deployment-774878f86f-ct8hj</code>这个pod，然后k8s很快就起了一个新的pod<code>k8s-demo-deployment-774878f86f-kfhm7</code>来保证数量为3，这就非常完美了，这样子线上环境中某个节点挂了，那么k8s就可以帮我们快速的新建一个pod来维持数量，这样子就不会如果支撑不住，导致整个集群挂掉，那这可就惨了。</p><p>既然容器起来了，那我们访问一下nginx，现在容器是在k8s内部起来了，并没有做端口映射，所以目前我们还访问不到，k8s是通过service来做映射访问的，我们来看一下service定义文件serivce.yml<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s more service.yml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line"> name: k8s-demo-service</span><br><span class="line"> labels:</span><br><span class="line">  app: k8s-demo</span><br><span class="line">spec:</span><br><span class="line"> type: NodePort</span><br><span class="line"> ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    nodePort: 30050</span><br><span class="line"> selector:</span><br><span class="line">  app: k8s-demo</span><br></pre></td></tr></table></figure></p><p>重点关注selector，这里将会把label为<code>app: k8s-demo</code>的容器的80端口映射到node节点的30050端口，我们刚才的deployment.yml文件中定义的label就是<code>app: k8s-demo</code>,也可以看一下现在的运行的pod的描述<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl describe pod k8s-demo-deployment-774878f86f-gxrp7</span><br><span class="line">Name:           k8s-demo-deployment-774878f86f-gxrp7</span><br><span class="line">Namespace:      default</span><br><span class="line">Node:           minikube/10.0.2.15</span><br><span class="line">Start Time:     Sun, 07 Apr 2019 18:05:29 +0800</span><br><span class="line">Labels:         app=k8s-demo</span><br><span class="line">                pod-template-hash=3304349429</span><br><span class="line">Annotations:    &lt;none&gt;</span><br><span class="line">Status:         Running</span><br><span class="line">IP:             172.17.0.6</span><br><span class="line"></span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p><p>通过命令<code>kubectl create -f service.yml</code>来创建service<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl create -f service.yml</span><br><span class="line">service/k8s-demo-service created</span><br></pre></td></tr></table></figure></p><p>然后通过这个service把endpoint暴露出来<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s minikube service k8s-demo-service --url</span><br><span class="line">http://192.168.99.100:30050</span><br></pre></td></tr></table></figure></p><p>访问这个url<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s curl http://192.168.99.100:30050</span><br><span class="line">&lt;h1&gt;Hello Docker&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>跟我们本地构建镜像启动容器访问的时候看到的是一样，只是这个端口映射我们是写成了yml配置文件，而本地镜像是启动容器的时候指定的。</p><p>好了，到目前为止，我们已经部署了一个服务实例，回过头来看看，这个和我们本地启动容器有什么区别，或者优势在哪里？咋一看好像还变复杂了，看起来是复杂了，但其实对于运维人员来说变得相当简单了，而且这样子更加的规范，也更加的灵活了，还有很重要的一点就是比较符合现在大多数的部署场景。</p><p>梳理一下流程，开发人员写代码的时候一般源代码下边都会有一个Dockerfile文件，这样子每次提交代码的时候都会触发Jenkins来构建镜像并push到我们内部搭建私有仓库中，并且配套有deployment.yml和service.yml文件，做完了CI之后，接下来就是CD的过程，触发k8s应用这两个文件来完成滚动更新部署。这样子运维人员只需要点击一下发布按钮来触发，开发人员通过提交代码来触发，自动完成这个CI/CD过程，整个过程所需要关心的就是Dockerfile，deployment.yml,service.yml这三个文件，这么说来是不是觉得非常轻松了，而且运维还不用担心应用什么时候挂了，有了k8s，假期期间再也没有接到夺命连环call了。</p><p>Kubernetes确实非常好用，应用场景也会越来越多，目前我们内部的平台就只是用来做CI/CD，有些公司也用来搭建深度学习平台等等，以后肯定也会越来越多，但是k8s帮我们做了很多内部的事情，这个还是比较有分量，用好它也不是一件容易的事。我们已经部署出来了一个服务，下面我们来看看滚动更新，这样子就完整的介绍了CI/CD的这个场景下使用k8s。</p><h2 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h2><p>假设我们修改了代码，我们这里就修改index.html的内容，方便做对比<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  html more index.html </span><br><span class="line">&lt;h1&gt;Hello Kubernetes&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>接下来就是提交代码自动构建镜像，这里我们手动构建,tag修改为0.2<br>接下来我们需要修改一下deployment.yml这个文件来适配滚动跟新<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: </span><br><span class="line"> name: k8s-demo-deployment</span><br><span class="line">spec:</span><br><span class="line"> replicas: 3</span><br><span class="line"> minReadySeconds: 10</span><br><span class="line"> strategy:</span><br><span class="line">  type: RollingUpdate</span><br><span class="line">  rollingUpdate:</span><br><span class="line">   maxUnavailable: 1</span><br><span class="line">   maxSurge: 1</span><br><span class="line"> template:</span><br><span class="line">  metadata:</span><br><span class="line">   labels:</span><br><span class="line">    app: k8s-demo</span><br><span class="line">  spec:</span><br><span class="line">   containers:</span><br><span class="line">    - name: k8s-demo-pod</span><br><span class="line">      image: k8s-demo:0.2</span><br><span class="line">      ports:</span><br><span class="line">       - containerPort: 80</span><br></pre></td></tr></table></figure></p><p>主要是增加滚动跟新的配置，如果一开始就有的话保持原样不用修改，<code>minReadySeconds: 10</code>指在更新了一个pod之后，需要在它进入正常状态10秒之后再更新下一个pod，<code>maxUnavailable: 1</code>指同时处于不可用状态pod不能超过1个，<code>maxSurge: 1</code>指多余的pod不能超过一个，这样子Kubernetes就会逐个替换所有的pod，运行命令<code>kubectl apply -f deployment.yml --record=true</code>来滚动更新，这里<code>--record=true</code>是让Kubernetes把这行命令记录到发布历史中备查<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl apply -f deployment.yml --record=true</span><br><span class="line">deployment.extensions/k8s-demo-deployment configured</span><br><span class="line">➜  k8s kubectl get pods</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-demo-deployment-774878f86f-gxrp7   1/1     Running   0          1h</span><br><span class="line">k8s-demo-deployment-774878f86f-v77hl   1/1     Running   0          1h</span><br><span class="line">k8s-demo-deployment-86dbd79ff6-g45m8   1/1     Running   0          5s</span><br><span class="line">k8s-demo-deployment-86dbd79ff6-mkxbx   1/1     Running   0          5s</span><br></pre></td></tr></table></figure></p><p>可以看到当前正在pod正在替换，使用命令<code>kubectl rollout status deployment k8s-demo-deployment</code>可以实时查看更新状态，但是更新太快了，不太方便。但是我们可以看一下pod的age，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s kubectl get pods                                     </span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-demo-deployment-86dbd79ff6-5l8gz   1/1     Running   0          22s</span><br><span class="line">k8s-demo-deployment-86dbd79ff6-g45m8   1/1     Running   0          34s</span><br><span class="line">k8s-demo-deployment-86dbd79ff6-mkxbx   1/1     Running   0          34s</span><br></pre></td></tr></table></figure></p><p>之前都是1h左右，现在是几十秒，说明是新建的，我们来验证一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  demo curl http://192.168.99.100:30050</span><br><span class="line">&lt;h1&gt;Hello Kubernetes&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>确实修改了，到这里我们就完整的讲述了CI/CD的整个流程。</p><p>到这里我们基本上把Kubernetes用起来，但是还有很多的东西值得我们去学习，官网的文档就是最好的学习资料，这里还要再次赞美Kubernetes的官方文档，真的真的写的非常通俗易懂。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2019/04/01/rabbitmq/"/>
      <url>/2019/04/01/rabbitmq/</url>
      
        <content type="html"><![CDATA[<p>目前大部分的后台系统都引入了MQ，不管是ActiveMQ还是RabbitMQ，亦或是RocketMQ、Kafka等等，MQ的主要作用是对系统进行解耦、异步化以及削峰，解耦应该是最常用的场景，本文将围绕这一业务场景以RabbitMQ作为案例来进行阐述。<br><a id="more"></a></p><h2 id="认识MQ"><a href="#认识MQ" class="headerlink" title="认识MQ"></a>认识MQ</h2><p>MQ的全称为Message Queue，中文翻译为消息队列，Java中定义了一系列的接口规范，这套规范叫做JMS，像ActiveMQ就是遵循JMS规范，我之前也用过一段时间的ActiveMQ，由于系统没有什么并发压力，数据量也不大，ActiveMQ确实也挺适合的，但是ActiveMQ更新速度太慢了，我想主要的原因是官方觉得比较成熟了吧。</p><p>接下来讲讲今天的主角，RabbitMQ也属于消息队列，但是它是用Erlang写的，所以谈不上遵循JMS规范，RabbitMQ遵循的是AMQP协议，AMQP协议是一个提供统一消息服务的的应用层标准的消息队列协议，不受语言限制，由于底层使用的是专门面向并发的Erlang语言，所以RabbitMQ的吞吐量非常优秀，而且目前社区非常活跃，基本上现在的微服务系统都是通过集成RabbitMQ来作为消息传递的。</p><p>这两者有什么区别呢？JMS定义了统一的接口来对消息操作，而且限定语言为Java；AMQP只是协议，不规定实现方式，不受语言限制，通过规定协议来统一数据交互的格式。</p><p>至于MQ的选型本文不做讨论，本文的主角是RabbitMQ，前面说过，MQ的常用场景是用来解耦，下面来看看两个我工作中的真实场景。</p><p>我是做云平台业务的，当底层对云资源做了修改之后，云平台是不知道底层做了修改，这时候怎么能让云平台知道呢？一般有两种方案，一种是底层对云资源做了修改之后，调云平台的修改接口，还有一种就是底层做了修改之后发布消息到消息队列，云平台去订阅消息。第二种方案很好的将云平台和底层进行了解耦，这种场景不是很频繁，底层的东西不会经常变动，这个是不符合原来的平台的设计原则的，消息吞吐量不大，ActiveMQ完全能够胜任。</p><p>还有一个业务场景是的云平台部署了一个云资源，部署完成了之后底层需要告知云平台已经部署完成，云平台才能做后续的事情，比如结束相关订单，生成服务实例来进行计费，报表开始将该资源纳入统计，通知监控平台纳管该资源进行监控，发送邮件，短信通知等等一系列相关的事情，如果都是在单体系统中还好，大不了都调一遍接口，或者和上一个场景中一样直接使用ActiveMQ，分不同的主题来订阅到不同的消息触发不同的逻辑操作，如果使用ActiveMQ的话这个时候消息吞吐量是相对比较大的，特别是目前架构已经演变成微服务架构了，不应该还采用之前的技术，应该全面拥抱微服务全套解决方案，微服务主要用的MQ就是RabbitMQ，而且RabbitMQ中的高级消息模型就可以满足我们上面的第二个业务场景，吞吐量也是完全Hold的住。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>因为RabbitMQ是有Erlang写的，安装之前需要安装相关依赖，这个可以参考官方文档来进行安装，我的是OS X系统，官方推荐直接通过<code>brew install rabbitmq</code>即可，这个最好要打开VPN，因为有些资源是挂在国外，brew已经处理好了依赖关系，等待安装完成即可。</p><p>安装完成之后通过命令<code>brew services start rabbitmq</code>，启动成功之后访问<code>http://127.0.0.1:15672</code>，使用默认用户名密码<code>guest/guest</code>登录，guest这个账户是RabbitMQ默认的管理员账户，拥有最高的权利，生产环境一般会新添加一个用户，赋予新用户管理员权限，然后把guest这个默认用户删除掉，这里只是我本地的环境，不用考虑安全因素。</p><p>接下来我们创建一个demo用户，并且给demo用户一个虚拟主机，这个虚拟主机待会试验的时候会用到。</p><p><img src="/asset/img/rabbitmq/add_user.png" alt="添加用户"><br><img src="/asset/img/rabbitmq/add_host.png" alt="添加host"></p><p>然后去用户详情或者host详情里边做好两者的关联，这里从用户这里进入</p><p><img src="/asset/img/rabbitmq/user_host.png" alt="添加关联"></p><p>这样子我们基本就完成了前期准备，下面来介绍消息模型。</p><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><h3 id="基本消息模型"><a href="#基本消息模型" class="headerlink" title="基本消息模型"></a>基本消息模型</h3><p>基本消息模型如下图所示，生产者将消息发送到消息队列中，消费者从消息队列获取消息，消息存储在队列里。<br><img src="/asset/img/rabbitmq/model1.png" alt="基本消息模型"></p><p>Consumer:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取到连接</span></span><br><span class="line">    Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">    <span class="comment">// 2.创建通道</span></span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">// 3.声明队列</span></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 4.定义队列的消费者</span></span><br><span class="line">    DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// body 即消息体</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">        System.out.println(<span class="string">" [Simple] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">        <span class="comment">// 手动进行ACK</span></span><br><span class="line">        <span class="comment">//channel.basicAck(envelope.getDeliveryTag(), false);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认,false要进行手动确认，保证消息的可靠性</span></span><br><span class="line">    channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Producer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取到连接</span></span><br><span class="line">    Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">    <span class="comment">// 2.创建通道</span></span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="comment">// 3.向队列发送消息</span></span><br><span class="line">    channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">    System.out.println(<span class="string">" [Simple] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    <span class="comment">// 4.关闭通道和连接</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Console:<br><img src="/asset/img/rabbitmq/model1_send.png" alt="发送"></p><p><img src="/asset/img/rabbitmq/model1_recv.png" alt="接收"></p><p>RabbitMQ中为了确保消息已经被消费了，会有一个确认机制来控制，可以设置为自动确认，如果想自己控制，可以设置为false之后手动进行确认，总之，消息确认机制从消费者端保证了消息被成功消费。</p><h3 id="work消息模型"><a href="#work消息模型" class="headerlink" title="work消息模型"></a>work消息模型</h3><p>当生产者产生消息比较多的时候，这就造成队列里边堆积了大量消息，这对系统来说是一个潜在的负担，这个时候就可以考虑work消息模型，多个消费者订阅同一个消息队里，多个消费者共享消息队列里的任务，但是一个消息只能由一个消费者消费。<br><img src="/asset/img/rabbitmq/model2.png" alt="work消息模型"></p><p>代码基本上和基本消息类型大同小异，完整代码见仓库中work包，生产者发送了50个任务，两个消费者消费消息,但是不是轮流来消费，看处理能力，只保证一个消息只会被消费一次！<br>Consumer-1:<br><img src="/asset/img/rabbitmq/model2_recv1.png" alt="Consumer-1"><br>Consumer-2:<br><img src="/asset/img/rabbitmq/model2_recv2.png" alt="Consumer-2"><br>Producer:<br><img src="/asset/img/rabbitmq/model2_send.png" alt="Producer"></p><h3 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布/订阅模型"></a>发布/订阅模型</h3><p>生产者产生消息，将消息发送到交换机，每个消费者都有自己的队列，队列连接到交换机，由交换机决定发送到哪个队列中，这样子可以实现一条消息可以被多个消费者消费。<br><img src="/asset/img/rabbitmq/model3.png" alt="发布订阅模型"></p><p>完整代码见仓库中publish包，两个消费者所在的队列绑定到同一个交换机上，生产者发送消息到交换机的时候两个队列都会收到消息，如果没有队列连接到交换机，那么消息将丢失。<br>Consumer-1:<br><img src="/asset/img/rabbitmq/model3_recv1.png" alt="Consumer-1"><br>Consumer-2:<br><img src="/asset/img/rabbitmq/model3_recv2.png" alt="Consumer-2"><br>Producer:<br><img src="/asset/img/rabbitmq/model3_send.png" alt="Producer"></p><h3 id="路由模型"><a href="#路由模型" class="headerlink" title="路由模型"></a>路由模型</h3><p>生产者产生消息，发送消息到交换机，交换机类为direct，这样子交换机就会根据配置的路由向指定的队列发送消息，而不会像所有连接到交换机的队列都发送消息，所以消息队列需要绑定一个routing key,生产发送消息的时候需要指定routing key，这样子就可以匹配上了。<br><img src="/asset/img/rabbitmq/model4.png" alt="路由模型"></p><p>完整代码见仓库中route包，两个消费者所在队列绑定到同一个交换机上，并且指定了routingKey，如图所示<br><img src="/asset/img/rabbitmq/model4_bind.png" alt="绑定形式"><br>生产者先发送routingKey为update，然后发送routingKey为delete,如图所示，与我们预期的结果一样。<br>Consumer-1:<br><img src="/asset/img/rabbitmq/model4_recv1.png" alt="Consumer-1"><br>Consumer-2:<br><img src="/asset/img/rabbitmq/model4_recv2.png" alt="Consumer-2"> </p><h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>路由模型是主题模型的一个特例，路由模型中的routing key是一个全匹配的key值，主题模型中key支持通配符，其中<code>#</code>匹配一个或多个值，<code>*</code>匹配不多不少一个词。<br><img src="/asset/img/rabbitmq/model5.png" alt="主题模型"><br>完整代码见仓库中topic包，两个消费者所在队列绑定到同一个交换机，Consumer-1的routingKey为item.#,Consumer-2的routingKey为item.*，如图所示<br><img src="/asset/img/rabbitmq/model5_bind.png" alt="绑定形式"><br>生产者先发送routingKey为item.delete，然后发送routingKey为item.delete.test,如图所示，与我们预期的结果一样。<br>Consumer-1:<br><img src="/asset/img/rabbitmq/model5_recv1.png" alt="Consumer-1"><br>Consumer-2:<br><img src="/asset/img/rabbitmq/model5_recv2.png" alt="Consumer-2"> </p><h2 id="SpringBoot集成"><a href="#SpringBoot集成" class="headerlink" title="SpringBoot集成"></a>SpringBoot集成</h2><p>SpringBoot是有AMQP-starter的，引入SpringBoot项目即可，然后在application.yml中配置RabbitMQ的信息，接下来就是写一个listener即可，真的是太方便了，完整代码见仓库spring包，运行ListenerTest即可验证。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">      value = <span class="meta">@Queue</span>(value = <span class="string">"exchange.spring.queue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">      exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">          value = <span class="string">"exchange.spring"</span>,</span><br><span class="line">          ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">          type = ExchangeTypes.TOPIC</span><br><span class="line">      ),</span><br><span class="line">      key = &#123;<span class="string">"#.#"</span>&#125;))</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"接收到消息："</span> + msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，附上仓库地址</p><div class="github-widget" data-repo="ruanzz/RabbitMQ-Tutorial"></div>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful API</title>
      <link href="/2019/03/31/restful/"/>
      <url>/2019/03/31/restful/</url>
      
        <content type="html"><![CDATA[<p>前后端分离之后，前后端人员通过接口数据进行交互，目前大部分都是通过RESTful API来进行的，双方各司其职，各发挥长处，但是同时也带来了沟通成本的增加，那么你了解REST吗？你的API是RESTful的吗？本文将和工作中内容关联起来阐述我眼中的REST。<br><a id="more"></a></p><blockquote><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</p></blockquote><p>看了REST的定义，什么也没明白，下面我来说说什么是REST，如何让你的API设计成RESTful。</p><p>REST把所有的东西都看成资源，RESTful的接口为 动词 + 名词，比如我们订单接口，那么订单就可以认为是一种资源，可以通过URI接口来获取，那么获取资源接口就可以设计成 <code>GET</code> <code>/orders</code>，这就是动词 + 名词。</p><p>动词常用有四种： <code>GET</code> <code>POST</code> <code>PUT</code> <code>DELETE</code><br>名词就是特定的资源了，和具体的业务有关，是名词就行。</p><ul><li><code>GET</code> /orders 获取订单列表</li><li><code>GET</code> /orders/{id} 获取某个订单</li><li><code>POST</code> /orders 新增订单</li><li><code>PUT</code> /orders/{id} 修改某个订单</li><li><code>DELETE</code> /orders/{id} 删除某个订单</li></ul><p>还有一个就是状态码的管理,但是这个工作中用的不怎么规范。<br>【成功状态】</p><ul><li><code>GET</code> <code>200</code> OK</li><li><code>POST</code> <code>201</code> Created</li><li><code>PUT</code> <code>200</code> OK</li><li><code>DELETE</code> <code>204</code> No Contents<br>【错误状态】</li><li><code>500</code> 服务器内部错误</li><li><code>503</code> 服务器无法处理请求</li><li><code>400</code> 错误请求，请求体不对</li><li><code>405</code> 错误请求，请求方法不对</li><li><code>401</code> 错误请求，身份认证通不过</li><li><code>403</code> 错误请求，未授权</li></ul><p>这就是常用的接口设计方案，这样子的接口就是符合RESTful的，看起来挺简单，但是这个跨越却是历史性，这样子接口的设计就会有一个规范，大家都默认这种描述资源的方式比较直观，接口都是通过json来传递数据，比较轻量级，这样子就统一起来，不像之前只有GET和POST，而且接口都是开发人员随便起的，因为这个接口只有他一个人用，还有可能通过xml数据传输，即使提供出去，那也是一团糟。</p><p>说完了REST和RESTful，来讲讲工作中都怎么用。</p><p>现在常用的REST框架有Jersey和CXF，当然SpringMVC也是支持RESTful API的，目前来说,SpringMVC是主流，之前项目中有用Jersey，我觉得Jersey也挺好用，而且内置jetty来处理Web请求，有点类似目前主流的SpringBoot的一部分功能。</p><p>最近在和一个第三方厂商对接接口，我开发完成了接口，想要做一个模拟对接服务，代码肯定是不能写在项目中，只能另外写一个项目来提供对接接口，当时首先想到的就是SpringBoot来提供一站式解决方案，简单快捷，但是后来想了想觉得有点重了，只是提供一个模拟接口而已，只需要提供要给接口出来返回json就行，想到了之前用过Jersey，就用Jersey+Gson来完成了，今天也开了个仓库来记录，以后可能还会用到。</p><div class="github-widget" data-repo="ruanzz/Api"></div><p>把项目clone下来之后，运行<code>ApiApplication</code>的<code>main()</code>方法就可以把一个REST服务跑起来，借助的是内嵌的Jetty服务器，看到这里是不是觉得和SpringBoot有点类似？是的，软件的思想其实都是殊途同归的，触类旁通很重要。</p><p>接下来访问增删改查接口</p><p>curl -H ‘Content-Type:application/json’ -XPOST <a href="http://127.0.0.1:8080/demos" target="_blank" rel="noopener">http://127.0.0.1:8080/demos</a> -d ‘{“id”:5,name:”demo5”}’<br>{“id”:5,”name”:”demo5”,”createTime”:”2019-03-31 56:22:37”}</p><p>curl -XGET <a href="http://localhost:8080/demos/5" target="_blank" rel="noopener">http://localhost:8080/demos/5</a><br>{“id”:5,”name”:”demo5”,”createTime”:”2019-03-31 56:22:37”}</p><p> curl -H ‘Content-Type:application/json’ -XPUT <a href="http://127.0.0.1:8080/demos/5" target="_blank" rel="noopener">http://127.0.0.1:8080/demos/5</a> -d ‘{name:”demo5-1”}’<br>{“id”:5,”name”:”demo5-1”,”createTime”:”2019-03-31 56:22:37”}</p><p> curl -XDELETE <a href="http://127.0.0.1:8080/demos/5" target="_blank" rel="noopener">http://127.0.0.1:8080/demos/5</a><br>“sucess”</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职场系列(二)</title>
      <link href="/2019/03/24/office-skill/"/>
      <url>/2019/03/24/office-skill/</url>
      
        <content type="html"><![CDATA[<p>之前写了篇文章讲述了毕业之后的组织架构调整，最近又大调整了一次，感想颇多，想记录一下，但是又不知道取什么标题，因为这些都是一些零碎的感悟，只能是作为文字记录，后续应该还会有类似的文章，因此萌生了一个想法，将这些弄成一个系列，因此有了这个系列的第二篇文章。<br><a id="more"></a></p><h2 id="情商"><a href="#情商" class="headerlink" title="情商"></a>情商</h2><p>程序员这个职业不需要什么情商吧？你是不是曾经在脑海里飘过这个问题呢？程序员目前已经是被大众比较认可的职业，但是提起程序员，大家的印象是什么呢？很多人知道这个梗，比如牛仔裤、运动鞋、优衣库衣服(格子衬衫以及黑色羽绒服)，还有一个比较突出的就是不懂人情事故，比较木讷。这些都是大众对程序员的印象，亲切称之为典型程序员，不知道大家对这个有什么感受或者想法，我自己的话是挺不舒服，但是这确实是广大程序员的真实写照，更有甚者的梗是程序员是高薪接盘侠，女孩子在外面经历过风雨之后想找一个老实多金的人嫁了过日子，首选目标是程序员，对于这种现象，我只能惋惜。很不幸，也许大千程序员中的你我或许可能就是下一个，所以，程序员在追求技术的道路上，段位也要相应的提高。</p><p>情商这个东西不是天分，也不是遗传，更多的是后天所经历过的事刻意有为的锻炼造就的。比如，一个交过很多个女朋友的男生比那些还没交过女朋友的男生的情商就高出不少，所以，情商高的标准是什么？人是有社交属性的，情商是通过社交属性来体现的，在我看来，如果一个人跟其他人沟通能够很顺畅，让对方感觉到舒服的，那么情商就是达标的。典型的像销售或者售前这些岗位，他们的任务就是搞定客户，怎么搞定客户呢？那就是满足客户，让他们很舒服，这样子他们就会很乐意把单子给你。</p><p>程序员的工作主要是产出代码，所以沟通的时间相较于售前是非常少的，只会埋头干活，当有一天抬头看路的时候，发现自己在这条路上已经越走越远了，可悲吗？有点可悲，可怜吗？一点不可怜！醒悟那么晚是有自己本身的原因，所以要经常反思，不断调整。程序员首先是一个社会职业，其次才是程序员，只要是社会职业，那就必须要进行沟通，沟通是需要技巧的，很多时候程序员都不太注意，典型的就是脾气暴躁，或者一句话能让全场冷场，甚至让对方尴尬得想找个洞钻下去，这些在大家都是程序员一起沟通的时候并不怎么感觉的出来，但是当程序员和老板吃饭，和售前、销售聚餐的时候，特别是想说一些恭维的话的时候，总是觉得不那么舒服，听者更加觉得不舒服了，和售前、销售在一起的时候更加相形见绌了。</p><p>这一条努力吧，沟通要一开始都是礼貌的，后续如果需要自己态度强硬，那就一口咬死，但是要注意自己的说话语气，整个过程语气都是平稳，给人很稳扎的感觉，落落大方，沟通过程中如果出现不能把握的事，有人会慌，人一慌就会出现说话的声音发生变化，这个是明显可以感觉得出来，如果平时注意的话应该在大家身边都会有这样的事，这就给别人一个信息，对方目前处于劣势，对方就会非常猛的进攻，所以，一个五尺男儿要有担当，遇到任何事都不要慌，首先就要从声音和肢体语言开始，声音要依旧保持浑厚，掷地有声，肢体要放轻松，做好迎接接下来发生的事情。</p><p>总结一下就是说话自带个人魅力，能够三思而后行，为自己说的话负责。和情商高的人交流，无关利益的时候让你感到很舒服，有利益纠葛的时候让你心甘情愿的吃亏。</p><h2 id="做事"><a href="#做事" class="headerlink" title="做事"></a>做事</h2><p>工作，就是一直做事，不断的有事情需要你去解决。所以，工作能力最直接的体现就是你的做事能力，是否高效解决事情，和你合作的同事对你的解决方法是否满意，是否带来收益？这些都是实实在在的，有目共睹的东西，很多时候，个人能力就是在做事的过程中提升的，也会影响个人绩效以及升职加薪等，这些在你的上级眼里都是格外清楚的。</p><p>特别是在开发中，你提供出去的接口别人一调就报错，这就很尴尬了，你这也太不靠谱了吧！很明显自己都没有测试过，所以经过自己手上的代码一定要搞得起码没有低级错误了才能提供接口出去，经过自己手的代码一定要比上一个版本要好，就算是接手别人的代码，该大改还是要大改，不合理就要改，因为经过你手了，后续就是要你来维护，出问题了你总不能说这些代码不是你写的，这种话只要一说出口，别人对你的印象就是不负责，喜欢推脱，三个字就是不靠谱。</p><p>还有一个特别重要的就是联调，你提供的接口一定一定是要通过模拟测试之后才能拿去联调的，不然丢人的不仅仅是你，还有你的公司，所以一定一定要格外的重视，前期沟通好接口，形成文档，双方按照文档来开发，后期联调接口经过模拟测试，到联调的时候就会少了很多麻烦，至少不会是因为你的原因出现一些低级错误，这是非常非常重要的。</p><h2 id="汇报"><a href="#汇报" class="headerlink" title="汇报"></a>汇报</h2><p>原来我们组是每周跟主管写一下周报，目前我们组每周五都要跟部门经理汇报本周工作，这个时候明显的感觉到除了主管，我们这些开发人员明显不懂汇报，主要的体现在汇报的时候像聊天一样，感觉做的事没有啥好说的，作为开发人员的你是不是有同感呢？</p><p>这样是不对的！经理管理需要的是大方向，不需要很细的东西，他不关心也不懂，他只关心这东西你要做多少时间，什么时候出成果，交付之后客户的满意度等等，而大多数的开发人员关心的是，这个需求我该怎么实现，可以使用什么设计模式，这段逻辑还可以怎么优化等等这些，很多时候开发人员就把这些汇报给经理，但是感觉经理好像不怎么想听，所以就觉得没有啥好说的了。</p><p>汇报需要材料，材料说白了就是文字，这时候文字功底就体现出来了，文字是需要勤加练习的，需要反复的推敲，特别是给上级做汇报或者递交材料的时候，一个好的文采或者直击要点的文字往往能够引起重视，从而推动事情往好的方向发展。人民日报以及政府工作报告就是一个很好的例子，这都是很多资深编辑经过推敲的文字，言简意赅，没有多余的废话。这个功力只能靠时间和多推敲来训练，这也是我当初开始写博客的原因之一。</p><p>除了文字，一般还需要PPT加持,开发人员的PPT功力是不敢直视，真的非常简陋，很多时候都是只是文字的堆砌，冷不丁的来一张图片，真的不忍吐槽，PPT基本是一个摆设或者附和完成的东西，更多的是汇报的时候口头表述，但是表述的时候又觉得没啥好汇报，这真的很尴尬，可以说身边不少程序员的PPT功底是不过关的，幸好还有公司模板，即使只是堆砌文字也不觉得很Low，但是给人是不舒服的，可以看出你是应付了事。所以，一定要反复修改，反复推敲，PPT是一个辅助工具，不能帮倒忙，可以通过视觉的形式很好的让你的领导知道你都干了什么，成果有哪些，遇到什么困难等，重点的东西要凸显出来。</p><p>文字和PPT都准备好了，接下来就是会议汇报了，汇报其实就是向某个人说某件事，重点在说，所以说的方式很重要，情商这个时候就要派上用场了，可以参照前边的说话自带个人魅力，捡重点的说，什么是重点，领导关心的东西是重点，PPT要重点展示的是重点，把这些东西说清楚了，领导就知道你干了什么，成果如何等等，让领导快速的了解你的工作，给他很舒服的感觉，那么恭喜你离升职加薪不远了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化思路</title>
      <link href="/2019/02/06/mysql-optimize/"/>
      <url>/2019/02/06/mysql-optimize/</url>
      
        <content type="html"><![CDATA[<p>MySQL优化是在工作中必须要学会的一个技能，在优化之前有一个非常重要的问题，必须要对MySQL进行优化了吗？是否可以从代码层面(业务或者架构)来提高效率呢？假设必须要对MySQL层面优化，那么问题来了——如何下手？先观察后优化！先定位问题出现在哪里，然后才是有针对性的去调优。<br><a id="more"></a></p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>一般我们会先观察的MySQL Server服务的查询数量以及线程数量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot ext -proot | awk <span class="string">'/Queries/&#123;q=$4&#125;/Threads_connected/&#123;tc=$4&#125;/Threads_running/&#123;tr=$4&#125;END&#123;printf("Queries\tThreads_connected\tThreads_running\n%d\t%d\t%d\n",q,tc,tr)&#125;'</span></span><br></pre></td></tr></table></figure></p><p>还有当前在处理的线程的的状态<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span> \G;</span><br></pre></td></tr></table></figure></p><p>重点关注<code>Copying to temp table</code>和<code>Sorting result</code>状态，这两种状态是常见的非常耗资源的状态。如果查询量比较大的话还可能会在<code>Sending data</code>阶段耗费长时间，这个时候就应该要考虑是否可以分页或者减少查询字段了。<br>我们还可以借助profile来观察每条语句在各个过程消耗的时间,一般profile是OFF的，我们需要将它开启<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看profile状态</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'profiling'</span>;</span><br><span class="line"># 开启profile</span><br><span class="line"><span class="keyword">SET</span> profiling=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure></p><p>之后的SQL语句都会有详细的记录，可以借助下面两条语句来查看<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看全部语句的各自花费时间</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROFILES</span>;</span><br><span class="line"># 查询某条语句各个过程花费的时间</span><br><span class="line"><span class="keyword">SHOW</span> PROFILE <span class="keyword">FOR</span> <span class="keyword">QUERY</span> &#123;query_id&#125;</span><br></pre></td></tr></table></figure></p><p>但是最重要的分析语句执行过程是<code>explain</code>来分析，后边会重点说这个。</p><h2 id="优化过程"><a href="#优化过程" class="headerlink" title="优化过程"></a>优化过程</h2><p>了解了定位的时候主要看哪些指标，那么我们在开发过程中就要注意一下，不要等到需要优化了才去explain每条语句优化。我们应该从建表到写SQL语句都需要考虑性能问题。</p><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>表结构要合理拆分。 </p><p>定长与变长分离，常用字段与不常用字段分离，用主键进行关联，根据业务特点合理添加冗余字段，字段的选取尽量选择合适的，存储够用就行，大存储字段浪费内存，影响速度，像核心字段都用int，char，enum等定长结构，非核心字段的话用varchar，text等非定长字段，或者拆出来单独放一张表。</p><p>尽量避免使用NULL,既不利于索引也可能更加的耗存储。</p><p>如果表结构规划的的不合理，后续一个业务就要连接非常多的表才能查询出数据，这种时候就要从业务角度考虑了，不要为了满足数据库范式而写代码，数据库范式只是提供了一个准则，我们开发人员应该要根据具体的业务来完成表结构的合理规划，不然后续要改数据库表结构将会很痛苦。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是为了提高查询效率，下面我们来了解一下索引。</p><p>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。总结一下就是索引是数据结构。既然是一种数据结构的，那么就会有多种实现方式，比如B+Tree索引(平衡树，也可以理解为排好序的快速查找结构)、Hash索引。</p><p>常用的是B+Tree索引，Hash索引的理论查询时间是O(1),为什么不用它呢？Hash索引的存储是通过hash值进行计算，即使id是连续增长的，但是hash出来的值千差万别，存储的位置是随机的，还有一个致命的缺点就是不能对范围进行查询，更无法对排序优化，还有就是必须回行，通过索引拿到数据存储位置之后，必须回到表中去取数据。正是这些缺点导致Hash索引的使用场景非常有限，像memory表用的就是hash索引，不需要对数据库进行范围查询，只需要快速定位数据。B+tree是不是就很好了呢？目前来看是的，综合起来首先要满足业务，支持对返回查询，排序优化，然后尽可能快，这些基本上就满足了我们业务上的基本要求。</p><p>在MySQL中，索引属于存储引擎级别的概念，不同的存储引擎的实现方式也是不同的，在MySQL中常见的存储引擎有两种：MyISAM和InnoDB。</p><p>先来看一下MyISAM,使用B+Tree作为索引结构，也叫非聚簇索引，因为无论是主索引还是辅助索引，其结构都是一样的，叶子节点的data域存放的是数据表记录的地址，因此MyISAM的索引查找结果的过程为按照B+Tree搜索算法搜索索引，如果指定的key存在，取出其data域的值，然后以data域的值为地址，读取相应的数据记录。</p><p>再来看一下InnoDB,同样也是使用B+Tree作为索引结构，但是和MyISAM有很大的不同，甚至相反，叫聚簇索引。MyISAM的索引文件和数据文件是分离的，索引文件只保留了数据记录的地址，而在InnoDB中，数据文件本身就是索引文件，数据是直接存储在节点的data域中，所以InnoDB必须要有主键，不然数据找不到地方存储，也因此得名聚簇索引。这就带来了一个问题了，那辅助索引怎么办？InnoDB是这样子处理的，辅助索引的data域存储的是主键的值，这样子所有的辅助索引定位到节点之后就可以拿得到主索引的值，然后再去主索引的B+Tree中查找对应节点，取出节点中data域就是数据记录了。</p><p>了解了两种存储引擎实现的索引，我们来对比一下，先从主键索引来看，MyISAM的索引树信息很少，查找相对较快，查找到相应节点之后取出data域信息之后还要根据地址去取数据记录，InnoDB查找相对慢一点，查找过程中遍历的数据量较多，但是查找到相应节点之后直接在节点上去取出数据，不需要在另外的回行取数据，对于主索引来说，这两种方式相差不会太多，数据量大的时候MyISAM的优势就明显了；辅助索引呢就是MyISAM大胜了，InnoDB中的辅助索引找到了只是主索引的值，还得去主索引的B+Tree上查找一次，找到对应节点才能去到data域中的数据记录。这两种的差别是他们的最初的目标决定的，MyISAM的强项是查询，索引是加快查询的最有效的方法，因此MyISAM采取的是非聚簇索引的，使得无论是主索引还是辅助索引，效率基本上是一样。InnoDB是为了平衡查询和事务，MyISAM是不支持事务，如果业务上需要到事务，那还是老实选择InnoDB吧，但是同时也要尽量的发挥InnoDB索引的查询优势，主键的选取就是一个很关键，必须单调并且不宜过长，为什么必须单调呢？这个是数据结构致使的，只要使用的是B+Tree，主键就应该单调，如果不单调，在插入新数据之后，二叉查找树要保持树的平衡，就得重新排序，频繁的分裂调整整棵树的结构，效率是非常低的，使用递增方式可以有效的解决这个问题。为什么不宜过长呢？InnoDB的辅助索引查询效率并不高，尽量能不用就不用，但是现实业务往往是需要辅助索引的，辅助索引的data域存储的是主键的值，过长就会导致额外的存储过多，使得辅助索引非常大。</p><p>索引在提升查询效率上的效果是十分明显的，但是在实际项目中我们会发现有时候索引并不生效，那么什么情况下会导致索引失效呢？只有了解了索引没有生效的情况，在开发过程中才能避免。<br>1.where条件中用or，即使其中有条件带索引，也不会使用索引。可以考虑使用union或者in来替换or。<br>2.对于多列索引，没有按照索引的定义顺序使用查询，这种时候索引也不生效，可以调整查询条件顺序或者重新创建索引使其生效。<br>3.like模糊查询使用%开头，尽量避免使用%开头，以%结尾可以生效<br>4.索引列不要做任何操作，包括计算(包含大于，小于，不等于)，函数，类型转换等等这些操作都会使索引失效。<br>5.索引列是字符串没有加上引号会使得索引不生效。<br>6.把where后边的字段都加上了单列索引，是不会所有的索引都生效的，因为是独立索引，生效的只有一个。应该加上多列索引，多列索引生效的前提是要满足前缀要求。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>SQL语句我们一般是先满足业务要求，先把业务逻辑完成了，接下来才是有针对性的优化，可以借助Druid数据库连接池的监控或者在开发阶段开启慢日志查询，推荐使用Druid，可以清楚的知道哪些SQL语句比较慢，上线之后可能会出现问题。</p><p>接下来我们详细了解一下EXPLAIN</p><p>EXPLAIN命令是用来查看SQL语句的执行计划，直接在执行的SQL前面加上EXPLAIN命令之后执行即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from goods;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| 1  | SIMPLE      | goods | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2    | 100.00   | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">1 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>select_type ： 查询类型</p><pre><code>- SIMPLE 简单查询，不包含子查询或者UNION- PRIMARY 查询中若包含子查询，最外层查询类型为PRIMARY- SUBQUERY 查询中若包含子查询，里层的查询类型为SUBQUERY- DERIVED from的表是一个子查询来完成的，为派生表，这个其实也属于SUBQUERY- UNION 该表是通过union完成</code></pre><p>table ： 操作的表<br>partitions ： 操作的分区<br>type ： 访问类型，是通过何种方式找到数据</p><pre><code>- ALL 全表扫描- index 只遍历索引树- range 索引范围扫描，查询条件是between、or、in、&gt;、&lt;等这些都是range- ref 使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行- eq_ref 类似ref，区别在于使用的是唯一索引，多表连接中的唯一索引作为关联条件- const/system MySQL对查询进行了优化，并转换为一个常量时，使用这些类型进行访问- NULL MySQL在优化过程中分解语句，执行时甚至不用访问表或者索引，比如找索引列的最小值</code></pre><p>possible_keys ：可能用到的索引，但不一定会被使用<br>key ： 在查询中实际使用的索引<br>key_length ：索引字段的最大可能长度，并非实际使用长度<br>ref ： 表的连接匹配条件<br>rows ： 找到记录需要读取的行数<br>filtered ：符合条件的记录数的百分比所做的一个悲观估算值<br>Extra ： 显示上述信息之外的信息，但是确是非常重要的</p><pre><code>- Using index 索引覆盖- Using where 表示MySQL服务器将在存储引擎检索行后在进行过滤- Using temporary 表示MySQL需要使用临时表存储结果集，常见于排序和分组查询- Using filesort MySQL无法利用索引完成的排序操作称为文件排序- Using join buffer 表示获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果- Impossible where 表示where语句会导致没有符合条件的行- Distinct 表示找到第一个匹配行之后就会停止搜索其他的行</code></pre><p>清楚了explain的各个列的值的含义，哪些值是我们重点关注的呢？</p><p>先看type类型，尽量避免ALL全表扫描，对性能有要求的也尽量避免扫描全部索引，这种时候就要在开发的时候加上合适的索引</p><p>再来看看Extra列，如果出现了Using temporary或者Using filesort则需要多加关注。<br>Using temporary往往是因为GROUP BY的列没有索引，或者GROUP BY和ORDER BY的列不一样，这种情况下就会产生临时表，建议加上合适的索引。<br>Using filesort表示无法利用索引完成排序，进而使用文件排序，也有可能是多表连接时排序的字段不是驱动表的列，建议加上合适的索引。<br>Using where 通常是因为全表扫描或者全索引扫描(type为ALL或者Index)，又加上了where条件，建议加上合适的索引</p><p>怎么都是加索引呢？不是说不能增加太多的索引吗？</p><p>确实是这样子，工作中碰到的80%的查询优化问题可以通过加上合适的索引来解决问题，索引就是为了优化查询而诞生的，这是它的职责所在。太多的索引会带来什么问题呢？就是更新数据的时候都要更新索引，这就影响到新增、修改和删除数据的性能，如果对这几个有很高的性能要求的话需要注意索引的数量，但是我工作中还没遇到这种场景，而且大多数表的索引都在3个以内，这个数量应该还好。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈云</title>
      <link href="/2019/01/26/cloud-compute/"/>
      <url>/2019/01/26/cloud-compute/</url>
      
        <content type="html"><![CDATA[<p>什么是云？我的简单理解是对资源的动态管理，以前一直用的一个词叫做按需取用，按需付费。我目前所从事就是云计算行业，云计算最初提出来就是为了实现资源的动态管理，包括计算资源(CPU和内存)，网络资源和存储资源。动态这个是我自己的理解，更专业的叫做弹性，体现在两个方面：一个方面就是想什么时候要就什么时候要，需要的时候从资源池里边拿就行。一个方面是想要多少有多少，当然这个前提是不能超过你的整个资源池所能提供的上限。<br><a id="more"></a><br>云计算看起来挺简单的，就是对资源的动态管理嘛！不就是个管理系统嘛，分分钟搞定，话呢还先不要说的这么满！来看看云计算的发展历程就知道了，任何东西存在都有一个演进的过程。</p><ol><li>物理设备阶段<br>这个时候需要上线一个应用，直接买台物理机放在数据中心，装好操作系统，配好网络就可以准备上线应用了。物理设备有很好的性能，但是有一个很要命的缺点，不能做到很好的灵活性，首先它不能够达到想什么时候要就什么时候要，比如买台服务器，这个是需要采购时间的，采购回来还要配存储，装操作系统，配网络等等，这些都是需要时间的，就比如说采购吧，就算和供应商关系好，怎么也得一个星期吧，而且后期扩展内存，存储这些都是需要时间的，三个字总结就是不灵活！<br><strong>为了解决这个问题，引入虚拟化技术。</strong></li><li>虚拟化阶段<br>用户就是想要一台机器来部署应用，数据中心的物理设备都是很强大的，可以考虑从现有的设备虚拟出一个完整的机器出来给用户部署应用，完整的虚拟化出CPU，内存，网络，存储等资源。在现有物理设备上虚拟化出这些资源是非常快的，基本上几分钟内就能解决，如果是VSAN存储的话可能几十秒内就创建出一台虚拟机了。如果这台机器不用了，可以直接删除回收资源，这样子就能很好的解决物理设备的灵活性问题。<br><strong>但是新的问题又来了，怎么把物理设备虚拟化？</strong><br>提到虚拟化，不可避免的要提到VMware，这是一家低调赚钱的公司，虚拟化软件做的很好，性能也很好，软件也卖的很好，赚了非常多的钱，用一个案例来描述这家公司赚钱的程度，大部分的数据中心或多或少都用VMware的产品，至少我接触到的金融或者运营商客户基本都是在用，只要是X86机器，大部分都是装的ESXi，其余的是Xen或者KVM，据我所知，一个省级的运营商建造一个数据中心的经费是十几亿的人民币，这都是白花花的银子啊。扯远了，回到主题，VMware是一家商业公司，它的虚拟化软件代码是闭源的，要用就要付钱买license，但是世界上还会有很多有情怀的人的，一些大牛程序员觉得这个技术我也会，你能开发我也能开发出来，我开发出来就是不收钱，把代码拿出来分享给大家，这就是开源，不能让你一家独大，不能什么钱都让你赚了，开源的虚拟化软件有Xen和KVM,开源意味着代码你可以拿得到，但是hold不hold的住就是另外一个问题了，现在开源的主流应该是KVM，这个对技术的要求还是有一定的门槛。<br><strong>虚拟化软件解决了物理设备的灵活性，这就是云计算？</strong><br>答案很显然不是！技术和概念还是在不断的演进，因为还没到弹性的概念，到现在只是解决了物理设备的灵活性，可以从物理设备中虚拟化出一台机器，需要人工指定从哪台物理主机设备上虚拟化，可能还需要比较复杂的人工配置，比如CPU大小，内存要多大，磁盘放在哪个存储，将磁盘挂载到虚拟化出来的机器，需要多少块网卡，网卡的配置等等这些。所以，如果仅仅是虚拟化软件来管理物理主机的话规模一般不会很大，可能最多100台服务器就管不过来了，太复杂了。后期就会发现时间都会耗在这些人工配置上了，并且这百十来台服务器，还远达不到想要多少要多少的程度，走了一圈又回去了，这就尴尬了。规模大了，单凭虚拟化软件人工配置耗时比较长，如何解决？<br><strong>为了解决这个问题，用调度算法</strong></li><li>池化阶段<br>调度算法！算法就是这么一个神奇的东西，没有一点点防备，就这样子出现，带给我们惊喜。调度算法长什么样呢？要想调度，首先要把资源整合起来，对于数据中心来说就是把计算资源、存储资源、网络资源进行池化，把这些资源放在一个资源池里边，调度算法在这个资源池里边进行资源的调度，用户需要多少的CPU，内存，磁盘的虚拟机，调度算法就会自动在资源池里边寻找一台能满足用户需求的物理主机，在这台物理主机上虚拟化一台虚拟机，按照用户要的配置自动配置好虚拟机，用户就能直接用了。<br>好了，到现在已经实现资源的弹性了，就是常说的IaaS,这样子就足够了吗？显然不够，点几下鼠标一台虚拟机出来了，你还得登录到虚拟机上进行部署你的应用，如果是几十台虚拟机，你还是得人工去扩容，一台一台的去部署你的应用，哎，还得继续演进~<br><strong>云计算不仅要管资源，还要管应用</strong></li><li>应用阶段<br>应用阶段是我自己起的，为了实现应用的灵活性，于是又在IaaS上加了一层，用来管理资源以上的应用弹性问题。这个应用大致可以分为两种：一种是通用的应用，一种是自己的应用。先来说说通用，通用的应用比如说数据库，缓存，消息队列这些软件，大家的配置其实都差不多，我们只需把自己的应用对接起来用就完了，云平台需要保证的是提供的这些通用应用不能挂，而且配置不允许改变，所以云平台需要养一批人这些人来维护，比如说MySQL数据库，需要云平台这边的MySQL高手来维护这些MySQL应用，保证服务可用。作为用户，你可以专注于业务，其余数据库的性能问题都可以花钱交给云平台来做，比如数据库的分库分表，读写分离等等。再来看看用户自己的应用，自有应用要实现自动安装，这个是云平台帮不了你的，因为是你开发，只有你才知道如何部署，云平台所能做的就是提供自动化安装条件，自动化安装脚本得你来写，所以云平台往往会提供一个工具，能够让你在新创建出来的虚拟机进行自动化部署你的应用，实现应用层面的真正弹性。这些自动化部署工具有Chef、Puppet、Ansible等，后边应该会写一些文章来讲Ansible。当然了，2018年是容器元年，容器在2018年火了，容器也能很好的解决应用部署问题，但容器不仅仅就是这么点功能，后续应该也会写一些文章来讲讲Docker。</li></ol><p>看完了云计算的演进过程，再来看看云的分类：私有云和公有云。也有把私有云和公有云混合建设的，名字简单明了，就叫混合云，这个就不用细说了，先来看看什么是私有云，私有云就会把虚拟化软件和池化软件部署在别人数据中心里边，LZ从事的就是私有云方向。使用私有云的客户往往很有钱，自建IDC，然后买云厂商的解决方方案，让自己的IT基础建设池化，也叫云化。再来看看公有云，我想每个人接触云都是从公有云开始的，像国外的AWS，国内阿里云、腾讯云、百度云。公有云和私有云不同在于，云数据中心是云厂商自建的，从虚拟化软件到池化，再到服务器等物理设备都是云厂商一家提供的，用户不需要很大的时间和人力投入，只要注册一个账号，点几下鼠标就可以创建出一台虚拟机。</p><blockquote><p>说个题外话，不知道有没有人像我以前一样好奇，为什么云计算这个东西是电商公司做的非常好，国外的亚马逊，国内的阿里云，这都是电商巨头，现在又多了一个十分赚钱的业务【云计算】。为什么是电商公司而不是传统的IT巨头微软，IBM这些呢？跟我来细细品味，首先一个技术的诞生和蓬勃发展肯定是解决了某些业务场景所遇到的难题，电商的业务场景有哪些可能和云计算扯上关系呢？其实都是，最典型的就是大促，特别是国内的双十一，大家都在这一天疯狂的上淘系应用买东西，后台负载那是前无古人，后无来者啊，不能总是提前准备好很多的物理机来支撑这一天的大促，而且物理机也不能很快的进行扩容，所以总是部署了很多的物理机，以防业务中断，如果淘系应用在双十一这一天挂了，损失的可是千亿级别营业额！！还有大促过后，很多的物理机器都是闲置的，你还不能断电，这些机器都是嗜血的，不能赚钱还得养着他们，大促一天赚来的钱都不够养啊。这个时候做云就势在必行了，大促期间创建大量的虚拟机来支撑，双十一过后释放掉资源，包装成云产品卖给其他客户，又赚了一笔。但是做云这个真的太难了，首先肯定不能用商业软件，因为商业软件的费用非常高，而且这些商业软件的公司并没有这种业务场景，很快就会遇到瓶颈，这种时候只能用开源解决方案，但是得有高手在，要hold得住这些开源的东西，这也造就了阿里云的一批国内的顶尖高手。电商业务发展需要云平台的支撑，云平台撑住了又可以让电商更加繁荣的发展，这简直了，相辅相成，赚的可谓是让国内其他公司嫉妒啊，后来很多公司纷纷做云，或者纷纷做电商，但是都干不过阿里，很简单，后来者只能喝汤，还有业务和云不能做到相辅相成。开源的解决方案中目前比较主流的是KVM,以及池化平台OpenStack，这两个结合在一起应该算是云计算开源平台的标准了，几乎每个云计算厂商都有做兼容，甚至是二次开发。但是2018年，容器火了，淘系应用也全部容器化，为什么容器这么火，因为它完美的诠释了弹性计算，秒级启动，性能强大，几乎不浪费资源等特性深受大家追捧，但是这个并不是新兴的技术，是Linux内核支撑的，但是这也不得不佩服。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flag</title>
      <link href="/2019/01/18/flag/"/>
      <url>/2019/01/18/flag/</url>
      
        <content type="html"><![CDATA[<p>这个作为一个日期提醒自己，以后总结会需要到这个日期。<br>今天做了一个决定，几个月后会回来review</p><a id="more"></a><blockquote><p>2019/4/13</p></blockquote><p>男人的嘴，骗人的鬼，公司不是家，婆婆不是妈。</p><p>以后不会相信任何人许下的承诺，那东西不靠谱，准备简历吧，金三银四都快完了，可以去知乎回答“你什么时候想抽自己”这个问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能Nginx(一)</title>
      <link href="/2018/12/22/talk-nginx/"/>
      <url>/2018/12/22/talk-nginx/</url>
      
        <content type="html"><![CDATA[<!-- ![Nginx服务网关](/asset/img/nginx/nginx.png) --><p>Nginx是后端开发人员应该都会接触的一款基础软件，以支持高并发访问面世，在开发环境中经常会配置一些Nginx参数来支持我们开发，那么问题来了，你有系统的了解过吗？</p><a id="more"></a><h2 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么"></a>Nginx是什么</h2><p>Nginx是一个高性能的Web和反向代理服务器。</p><h2 id="Nginx应用场景"><a href="#Nginx应用场景" class="headerlink" title="Nginx应用场景"></a>Nginx应用场景</h2><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>Web服务器一般用来处理JavaScript，HTML，CSS等静态资源。同类产品有Apache，IIS,但是Nginx是C语言写的，并且使用的epoll and kqueue开发模型，占用更少资源，确拥有更高的性能。一般谈到Web应用服务器的时候往往会谈到Web应用服务器，比如Tomcat，Jetty等，Web应用服务器是处理Servlet程序的载体，Web应用服务器的并发能力远低于Web服务器。</p><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><p>首先理解一下什么是代理，默认是正向代理，代理的是客户端，通过客户端的设置，实现让一台服务器(代理服务器)来代理客户端，客户端所有的请求都交由代理服务器来处理，比如翻墙用的梯子就是正向代理最好案例。认识了代理，反向代理就和正向代理正好相反，用一台服务器代理真实的服务器，当有用户进行访问请求时，不再访问真实的服务器，而是访问代理服务器，有代理服务器将请求转发交给真实的服务器处理。<br>Nginx用来当反向代理服务器时，需要在Nginx的配置文件中配置好反向代理的规则，不同的请求交给不同的真实服务器处理，当请求到达Nginx时，Nginx会根据已经定义好的规则进行请求的转发，从而实现路由的功能，并且可以解决应用中通过域名访问的时候的端口问题。</p><p>在开发中，我们更多是把他当做网关，因为它具备网关必备的功能：</p><ul><li>反向代理</li><li>负载均衡</li><li>动态路由</li><li>请求过滤</li></ul><p>和SpringCloud中的Zuul网关一样，但是Zuul网关我们是用来做服务内部调用的网关，带有鉴权作用，Nginx作为外部网关，因为并发能力太强了，可以支持50000个并发，直接碾压Tomcat的200个并发。</p><h2 id="Nginx实践"><a href="#Nginx实践" class="headerlink" title="Nginx实践"></a>Nginx实践</h2><p>安装和启动这里就直接略过了，看到Nginx的欢迎页面就说明Nginx启动好了。</p><p><img src="/asset/img/nginx/visit-nginx.png" alt="访问Nginx"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>nginx.conf是Nginx的配置文件，它是由特定的标识符(指令符)分为多个不同的模块，这个文件就是前文讲过的配置反向代理规则的地方，接下来了解下Nginx的配置文件。<br>指令符分为简单指令和块指令:</p><ul><li>简单指令格式： name value;</li><li>块指令格式：  {name value;} </li></ul><p>块指令也可以称为上下文(e.g. events,http,server,location)，值得注意的是，所有不属于块指令的简单指令都属于main上下文，http块指令也属于main上下文，server块指令属于http上下文</p><h3 id="配置静态访问"><a href="#配置静态访问" class="headerlink" title="配置静态访问"></a>配置静态访问</h3><p>Nginx默认在http上下文中配置了一个server的块指令，监听80端口，访问<code>/</code>的时候就进入这个server中<br>，并且配置了server的根目录和首页。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><p>server可以配置多个，相当于配置多台server提供服务，但是都是通过80端口访问Nginx之后，通过Nginx的proxy_pass进行转发。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  tomcat111;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass  http://10.10.111.111:8090</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  tomcat112;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass  http://10.10.111.112:8090</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h3><p>1.轮询(默认)<br>每个请求按照时间顺序逐一分配到不同的后端服务器，按照服务器列表顺序来提供服务，如果down掉了，可以自动跳过。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver&#123;</span><br><span class="line">    server  10.10.111.111;</span><br><span class="line">    server  10.10.111.112;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.指定权重</p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver&#123;</span><br><span class="line">    server 10.10.111.111 weight=10;</span><br><span class="line">    server 10.10.111.112 weight=5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.IP绑定<br>每个请求按照请求IP的HASH结果分配，这样子每个IP固定访问一个后端服务，这个可以解决集群的session共享问题。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server  10.10.111.111;</span><br><span class="line">    server  10.10.111.112;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="配置Nginx解决跨域问题"><a href="#配置Nginx解决跨域问题" class="headerlink" title="配置Nginx解决跨域问题"></a>配置Nginx解决跨域问题</h3><p>跨域问题是浏览器为了安全性做的一个限制，请求的url和浏览器地址栏的url中端口|域名|协议不一样都属于跨域，我们可以借助Nginx的反向代理解决这个这个问题。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.xxx.com;</span><br><span class="line">    location /order &#123;</span><br><span class="line">        proxy_pass  http://search.a.com:8090</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    location /manage &#123;</span><br><span class="line">        proxy_pass  http://manage.a.com:8090</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="配置防盗链"><a href="#配置防盗链" class="headerlink" title="配置防盗链"></a>配置防盗链</h3><p>利用referer来做防盗链检查，只允许某个域名来请求资源，如果不是从某个域名来的，返回403未授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.xxx.com;</span><br><span class="line">    location ~ .*\.(jpg|jpeg|JPG|png|gif|icon)$ &#123;</span><br><span class="line">        valid_referers blocked http://www.xxx.com www.xxx.com;</span><br><span class="line">        if ($invalid_referer) &#123;</span><br><span class="line">            return 403;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx高可用"><a href="#Nginx高可用" class="headerlink" title="Nginx高可用"></a>Nginx高可用</h2><p>Nginx作为外部网关，如果只是一台的话存在单点故障，那么整个后端服务都不能提供服务，所以要搭建Nginx高可用，现在互联网应用基本都在关注这两点，高并发和高可用。我们借助Keepalived来实现高可用,那么接下来我们来了解一下Keepalived。<br>Keepalived从字面意思就可以知道它的作用–保持活着。官方的说辞是主要提供负载均衡(Load Blace)和高可用(high-availablity)功能。负载均衡实现需要依赖Linux的虚拟内核模块ipvs(IP虚拟服务器，用于实现网络服务的负载均衡)，高可用通过VRRP协议实现多台机器之间的故障转移业务。</p><h3 id="配置Keepalived"><a href="#配置Keepalived" class="headerlink" title="配置Keepalived"></a>配置Keepalived</h3><p>Keepalived的配置文件为keepalived.conf，配置说明如下:<br>Master节点<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   router_id nginx111 ##标识节点的字符串，通常为hostname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script "/etc/keepalived/nginx_check.sh" ##执行脚本位置，检查节点状态，根据返回结果动态调整权重</span><br><span class="line">    interval 2 ##检测时间间隔</span><br><span class="line">    weight -20 ## 如果条件成立则权重减20（-20）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER   ## 主节点为MASTER，备份节点为BACKUP</span><br><span class="line">    interface en0  ## 绑定虚拟IP的网络接口（网卡）</span><br><span class="line">    virtual_router_id 111  ## 虚拟路由ID号</span><br><span class="line">    mcast_src_ip 10.10.111.111 ## 本机ip地址</span><br><span class="line">    priority 100  ##优先级配置（0-254的值）</span><br><span class="line">    Nopreempt  </span><br><span class="line">    advert_int 1 ## 组播信息发送间隔，俩个节点必须配置一致，默认1s</span><br><span class="line">    authentication &#123;  </span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456 ## 真实生产环境下对密码进行匹配</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.10.111.110 ## 虚拟ip(vip)，可以指定多个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Backup节点:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   router_id bhz006</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script "/etc/keepalived/nginx_check.sh"</span><br><span class="line">    interval 2</span><br><span class="line">    weight -20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface en0</span><br><span class="line">    virtual_router_id 112</span><br><span class="line">    mcast_src_ip 10.10.111.112</span><br><span class="line">    priority 90 ##优先级配置,比master低</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.10.111.110</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx_check.sh 脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">A=`ps -C nginx –no-header |wc -l`</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    /usr/local/nginx/sbin/nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动Nginx和Keepalived，检查vip是否配置在对应的网络接口，干掉Master，Nginx还是能够正常提供服务。一般当某些服务出现问题，特别是像Nginx这些重要组件出现问题的时候，一般会从脚本文件中加上发送邮件的代码，或者有监控平台的话会以各种各样的方式比如短信、微信、钉钉进行通知。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端面试题整理</title>
      <link href="/2018/12/18/interview-summary/"/>
      <url>/2018/12/18/interview-summary/</url>
      
        <content type="html"><![CDATA[<!-- ![惠灵顿](/asset/img/interview-summary/Mac.jpeg) --><p>这个冬天有点冷，冬天了还是储藏点过冬的粮食，用倒推法来总结相关知识，这篇博客将会长期更新，收集网上的面试题，然后自己整理思路，以后自己肯定会用的上，也为以后博客积累素材。<br><a id="more"></a></p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><blockquote><p>1.String类有看过源码吗？和StringBuffer，StringBuilder有什么区别？</p></blockquote><p>String类是一个final不可修改的类,说明String类不能被继承，StringBuffer和StringBuilder都是用来拼接字符串用的，只有调用toString()方法的时候才会真正的new String()对象，定义字符串的时后字符量拼接是由JVM进行优化拼接成整体放入字符串常量池中，如果有字符串变量参与了字符串的拼接，那么底层是调用StringBuilder来进行拼接。StringBuffer是线程安全的，StringBuilder是线程不安全的，因此StringBuilder的性能会更好一点，有并发场景的话还是使用StringBuffer来比较合适。</p><blockquote><p>2.Throwable、Error、Exception区别和联系。受查异常和非受查异常都用过哪些，谈一下对他们的理解</p></blockquote><p>Throwable 是异常的顶层类，Error和Exception都继承了这个类，当然还有其他一些子类，在我们开发过程中常接触到也就是这两个类的子类，算是两种比较常用的异常处理。Error代表出现了非常严重的错误，JVM虚拟机无法处理，只能Crash，比如OutOfMemoryError。Exception是一般性的异常，这个一般性指的是不会造成虚拟机宕机，但是对开发人员来说，最复杂的也就是这块，对异常的处理是根据业务来的，是抛出去还是try起来，怎么对异常分类？这个都要根据具体的业务来决定，跟业务相关复杂性肯定不会小，因此如何处理好异常也是很有门道的。<br>Exception和Error本来是互不相关的，但是Exception中有一个叛徒RuntimeException，这个叛徒却是最受开发人员欢迎的，基本上自定义业务一样都会继承它，为什么说他是叛徒呢？它和Error一样，都是都是unchecked的，程序都会进行中止处理，除RuntimException及其子类外的Exception都是checked的，受查异常和非受查异常在在编译过程中就有体现出来，受查异常必须在代码层面做处理，不然编译不通过。常用的非受查异常有OutOfMemoryError,ClassCastException,NullPointerException等，常用的受查异常有：FileNotFoundException，NumberFormatException，NoSuchMethodException，IOException，ClassNotFoundException，InterruptedException等</p><blockquote><p>3.父类和子类之间加载的时候，代码块，构造块，构造方法，普通方法调用的顺序</p></blockquote><p>static静态成员变量或者静态代码块是JVM启动的时候加载，所以会优先执行这个，大概的顺序是代码块优先于构造方法，静态优先于非静态。执行的顺序如下：<br>1.父类静态成员变量和静态代码块<br>2.子类静态成员变量和静态代码块<br>3.父类普通成员变量和普通代码块<br>4.父类构造方法<br>5.子类普通成员变量和普通代码块<br>6.子类构造方法</p><blockquote><p>4.Java泛型有什么好处？是怎么实现的?</p></blockquote><p>泛型的的好处就是在编译的时候检查类型安全，把运行时异常提前到编译时异常，并且所有的强制转换都是自动和隐式转换，提高了代码的重用，不用到处都是显式的强制转换，让代码更加优雅。<br>Java泛型的实现原理是类型擦除，是在编译器这个层次来实现。什么是类型擦除呢？就是使用泛型的时候加上的类型参数，在编译的时候去掉，在生成的Java字节码文件中是不包含泛型中的类型信息的。比如，定义了一个<code>List&lt;String&gt;</code>类型，在编译之后都会变成<code>List</code>类型，JVM看到的只是<code>List</code>，而由泛型附加的类型信息是对JVM来说是透明的。</p><blockquote><p>5.说说你对面向对象、封装、继承、多态的理解。</p></blockquote><ul><li>封装 隐藏具体的实现细节，并且明确标识允许外部使用的成员方法和成员变量，防止数据被破坏。</li><li>继承 子类继承父类，拥有父类除private修饰的所有成员变量和成员方法，并且可以在父类基础上进行扩展，实现了代码的重用。</li><li>多态 一个接口有多个子类或者多个实现类，在运行期间(非编译期间)才决定所引用的对象的实际类型，再根据其实际的类型调用其对应的方法，也就是常说的”动态绑定“。有三个条件：继承、重写、向上转型。因此面试的时候往往就是说说多态的理解，这样子面向对象编程的精髓基本都会涉及了。<br>(1) 继承： 子类继承父类或者实现父类<br>(2) 重写： 子类重写从父类继承过来的方法<br>(3) 向上转型： 父类引用指向子类</li></ul><blockquote><p>6.private修饰的方法可以通过反射访问，那么private的意义是什么？</p></blockquote><p>private只是封装、OOP思想的一种体现，与安全什么的毫无关系。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><blockquote><p>1.Java的集合类框架介绍一下</p></blockquote><p>最顶层接口是分别是Collection和Map<br>【Collection】<br>Collection的实现类有List、Set和Queue。List的实现类有ArrayList和LinkedList等，ArrayList是一个可扩容的对象数组，LinkedList是一个双向链表。Set里的元素是不可重复，常见的有HashSet，TreeSet，LinkedHashSet等，HashSet的实现基于HashMap，实际上就是HashMap中的key。Queue的实现类有LinkedList，可以用作栈，队列和双向队列，另外还有ArrayBlockingQueue等。<br>【Map】<br>Map的实现类常见的有HashMap，TreeMap，LinkedHashMap和HashTable等，HashMap使用散列法实现，底层是数组+链表。TreeMap是根据键排好序的Map，使用红黑树实现。LinkedHashMap的实现综合了HashMap和双向链表，可保证以插入时的顺序进行迭代访问。HashTable和HashMap相比，HashTable是线程安全的，HashMap是线程不安全的，HashTable的键或值不允许为null，HashMap允许。</p><blockquote><p>2.集合容器类中使用了哪些设计模式？</p></blockquote><p>（1）迭代器模式，Collection继承了Iterable接口，其中的Iterator()方法返回Iterator对象，通过这个对象可以迭代Collection中的元素。<br>（2）适配器模式 <code>java.util.Arrays#asList()</code>可以将数组类型转换为<code>List</code>数据类型。</p><blockquote><p>3.ArrayList源码分析</p></blockquote><p><code>ArrayList</code>实现了<code>RandomAccess</code>接口，支持随机访问，底层是基于数组来实现，数组默认大小为10。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>（1）扩容   添加元素时使用<code>ensureCapacityInternal()</code>方法来保证容量足够，如果不够时，需要使用<code>grow()</code>方法来进行扩容,新容量的大小为<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>,也就是1.5倍。扩容操作需要调用<code>Arrays.copyOf()</code>方法把原数组整个复制到新数组中，因此最好在创建ArrayList的时候就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(2)删除元素 需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>(3)Fail-Fast机制  modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>(4)序列化机制 ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure></p><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>4.Vector源码分析</p></blockquote><p>实现大体上与ArrayList类似，但是使用synchronized进行同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E var1)</span> </span>&#123;</span><br><span class="line">    ++<span class="keyword">this</span>.modCount;</span><br><span class="line">    <span class="keyword">this</span>.ensureCapacityHelper(<span class="keyword">this</span>.elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.elementCount++] = var1;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 &gt;= <span class="keyword">this</span>.elementCount) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.elementData(var1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>Vector是同步的，因此开销肯定比ArrayList大，访问速度更慢，因此不建议使用，应该使用ArrayList，如果需要到同步，可以使用<code>Collections.synchronizedList()</code>得到一个线程安全的ArrayList,或者使用concurrent包下的CopyOnWriteArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br><span class="line">List&lt;String&gt; copyOnWriteList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>5.CopyOnWriteArrayList源码分析</p></blockquote><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>CopyOnWriteArrayList</code>在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。但是<code>CopyOnWriteArrayList</code>有其缺陷：<br>(1)内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>(2)数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以<code>CopyOnWriteArrayList</code>不适合内存敏感以及对实时性要求很高的场景。</p><blockquote><p>6.LinkedList源码分析</p></blockquote><p>基于双向链表实现，使用Node存储链表节点信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>并且每个链表存储了first和last指针：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></p><p>跟ArrayList相比：<br>(1)ArrayList基于动态数组实现，LinkedList基于双向链表实现<br>(2)ArrayList支持随机访问，LinkedList不支持<br>(3)LinkedList在任意位置添加删除元素更快</p><blockquote><p>7.HashMap源码分析(JDK1.7)</p></blockquote><p>(1)存储结构<br>包含一个Entry类型的数组table,Entry存储着键值对，包含了四个字段，从netx字段可以看出Entry是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap使用拉链法来解决冲突，同一个链表中存放哈希值相同的Entry。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)拉链法原理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"k1"</span>,<span class="string">"v1"</span>);</span><br><span class="line">map.put(<span class="string">"k2"</span>,<span class="string">"v2"</span>);</span><br><span class="line">map.put(<span class="string">"k3"</span>,<span class="string">"v3"</span>);</span><br></pre></td></tr></table></figure></p><p>新建一个HashMap,默认大小为16，插入&lt;k1,v1&gt;键值对，假设k1的hashcode为115，则115%16=3，则在table[3]插入&lt;k1,v1&gt;这个Entry，假设k2和k3的hashcode都是118，118%16=6，那么&lt;k2,v2&gt;和&lt;k3,v3&gt;都是插入table[6]这个桶内，&lt;k3,v3&gt;在&lt;k2,v2&gt;前面，即&lt;k3,v3&gt;的next元素是&lt;k2,v2&gt;,每次插入元素都是直接插入链表的表头。</p><p>(3)get操作<br>查找需要分为两步：<br>①计算键值对所在的桶<br>②在链表上顺序查找，时间复杂度显然和链表的长度成正比。</p><p>如何确定键值对的桶下标呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实就是两步，先计算hash值，然后对table长度取模。计算hash值这个方法很常规，关键是取模indexFor()这个方法很有意思，正常的写法应该是<code>h%length</code>,但是jdk源码里边写的是<code>h&amp;(length-1)</code>,第一次看到这个的时候我就愣了，jdk源码应该不会有这么大的bug！这两相等？研究了一下之后发现都是写代码的，人与人之间的差别不是一丁半点！！！</p><p>假设x=1&lt;&lt;4,即x为2的4次方，y的值为10110010<br>正常人取模：y%x<br>y:10110010<br>x:00010000<br>y%x:00000010<br>大神取模：y&amp;(x-1)<br>y:10110010<br>x-1:00001111<br>y&amp;(x-1):00000010</p><p>位运算的代价比求模运算小的多，因此带来更高的性能。但是这个有一个前提就是x必须是2的n次方，这样子x-1就会是一堆的1，和y做与运算之后就把y的高位干掉，只剩下低位，达到取模效果，这个不得不佩服！</p><p>(4)put操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HashMapy允许插入键为null的键值对，但是无法调用null的hashCode()方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap使用第0个桶存放键为null的键值对。<br>对于键不是null的键值对，使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><p>(5) 扩容原理<br>假设HashMap的table长度为M，需要存储的键值对数量为N，如果哈希函数满足均匀性的要求，那么每条链表的长度为N/M,因此平均查找次数的复杂度为O(N/M)。<br>为了让查找的成本降低，应该尽可能使得N/M尽可能小，因此需要M足够大，HashMap采用动态扩容来根据当前的N值来调整M值，使得空间效率和时间效率都得到保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 初始容量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最大容量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 默认负载因子 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Entry数组 */</span></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 键值对数量 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 阈值 */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 负载因子 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 修改次数 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>当需要size大于threshold时，需要进行扩容操作，capacity为原来的两倍，扩容操作需要把oldTable中的所有键值对重新插入newTable中，这个步骤是非常耗时的。因此，如果知道table大小的话最好通过构造函数传入，避免后续扩容造成性能问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么问题来了，扩容之后把原来table的entry复制到新的table中，并且table长度变了，那原来的hash值又要重新计算一遍？是的！HashMap使用了一个特殊的机制，可以降低重新计算桶下标的操作，假设原来的table长度为16(00010000)，扩容之后的table长度为32(00100000)，对于一个key，如果它的hash值第五位上为0，那么取模结果和以前一样，如果为1，那么得到的结果为原来的加上16。</p><p>(6)计算table容量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>8.ConcurrentHashMap源码分析(JDK1.7)</p></blockquote><p><code>ConcurrentHashMap</code>和<code>HashMap</code>实现上类似，最主要区别是<code>ConcurrentHashMap</code>采用了分段锁(Segment),每个分段锁维护着几个同(HashEntry),多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高，并发度就是Segment的个数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 默认的并发级别为 16，也就是说默认创建 16 个 Segment */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure></p><p>每个Segment维护一个count变量来统计该Segment中的键值对个数，在执行size()方法时，需要遍历所有的Segment然后把count累计起来。ConcurrentHashMap在执行size()时，先尝试不加锁获取，如果连续两次不加锁获取的结果一致，那么可以认为这个结果是正确的。尝试次数超过3次，就需要对每个Segment进行加锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。JDK 1.8 使用了CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁 synchronized。</p><blockquote><p>9.LinkedHashMap源码分析(JDK1.7)</p></blockquote><p><code>LinkedHashMap</code>继承自HashMap，因此有HashMap的所有特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>内部维护了一个双向列表，用来维护插入顺序或者LRU顺序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap最重要的是以下用于对维护顺序的函数afterNodeAccess()和afterNodeInsertion()，会在put、get等方法中调用。</p><p>当一个节点被使用时，调用get方法，如果assessOrder为true，则会将该节点移到链表尾部。也就是说指定为LRU顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行put操作之后，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。evict 只有在构建 Map 的时候才为 false，在这里为 true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote><p>1.Java中有几种方式可以创建线程？</p></blockquote><ul><li>继承<code>Thread</code>并重写<code>run</code>方法</li><li>实现<code>Runnable</code>接口并重写<code>run()</code>方法，并将作为参数传入<code>Thread</code></li><li>实现<code>Callable</code>接口并重写<code>call()</code>方法，<code>call()</code>方法有返回值</li><li>由线程池创建并管理线程</li></ul><blockquote><p>2.Java线程池怎么实现的？主要核心类讲一下</p></blockquote><p><code>Executors</code>是线程池的工厂类，通过调用它的静态方法来创建线程池，比如<code>newCachedThreadPool()</code>方法，这些静态方法统一返回一个<code>ThreadPoolExecutor</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                        RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数解释：</p><ul><li>corePoolSize: 指定线程池中线程的数量</li><li>maximumPoolSize: 线程池中最大的线程数量</li><li>keepAliveTime: 当线程池中的线程数量超过corePoolSize的时候，多余的线程最大的存活时间</li><li>unit: keepAliveTime的单位</li><li>workQueue: 任务队列，被提交但还未被执行的任务</li><li>threadFactory: 线程工厂，用于创建线程</li><li>handler: 拒绝策略，当任务太多来不及处理的时候，采用什么方式拒绝任务</li></ul><p>核心参数: workQueue和handler<br>【workQueue】<br>有<code>ArrayBlockingQueue</code>有界队列，<code>LinkedBlockingQueue</code>无界队列，<code>SynchronousQueue</code>直接提交队列<br><code>ArrayBlockingQueue</code>：当线程池中实际线程数小于corePoolSize时，直接创建线程执行任务，当大于corePoolSize时，提交到workQueue中，因为这个队列是有界的，当队列满时，在不大于maximumPoolSize的情况下，创建线程执行任务，如果大于maximumPoolSize，执行拒绝策略handler<br><code>LinkedBlockingQueue</code>：当线程池中实际线程数小于corePoolSize时，直接创建线程执行任务，当大于corePoolSize小于maximumPoolSize时，提交到workQueue中，因为队列是无界的，所以之后提交的任务都会进入队列中<br><code>SynchronousQueue</code>：该队列没有容量，对提交的任务不做保存，直接新增线程来执行任务。</p><p>【handler】</p><ul><li>直接抛异常</li><li>在调用者的线程中执行当前任务</li><li>丢弃最老的一个请求，将队列头的任务poll出去</li><li>直接丢弃无法处理的任务，不做任何处理</li></ul><blockquote><p>3.如何终止线程？</p></blockquote><ul><li>调用线程interrupt()方法，执行线程体业务代码之前使用interrupted()方法进行判断是否被中断，只有为false才会执行线程体,调用线程interrupt()方法之后线程体业务代码就不会再被执行。</li><li>直接调用线程的stop()方法，这是jdk6以前的做法，现在是不推荐了，因为会导致线程不释放锁，有可能会出现死锁情况。</li></ul><blockquote><p>4.说一下原子性，有序性，可见性</p></blockquote><ul><li>原子性：一个操作或者多个操作，要么全部执行成功，要么全部不执行。</li><li>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他的线程能够立即看得到修改的值</li><li>有序性：程序执行的顺序按照代码的先后顺序执行，不进行执行重排。</li></ul><blockquote><p>5.说一下Object对象的notify()和wait()方法</p></blockquote><p>Object对象中notify()和wait()是用来实现等待/通知模式，调用wait()方法之后线程进行等待状态，等待状态中的线程可以通过notify()方法唤醒并继续执行。等待和阻塞不同，阻塞状态的线程需要获取新的锁。wait()、notify()和notifyAll()方法需要配合synchronized使用。</p><blockquote><p>6.Synchronized实现原理</p></blockquote><p>synchronized可以保证方法或者代码块在执行时，同一时刻只有一个线程访问，同时还保证了共享变量的内存可见性。Java中的每一个对象都可以作为锁，属于重量级锁，jdk1.6之后进行了优化，由轻量级向重量级升级，偏向锁-&gt;自旋锁-&gt;轻量级锁-&gt;重量级锁来减少锁操作的开销。</p><ul><li>同步代码块：同步代码块锁的是括号里边的对象，monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之对应，当Monitor被持有之后，它将处于锁定状态，线程执行到monitorenter指令时，将会尝试获取对象所对应的Monitor所有权，即尝试获取对象的锁。</li><li>同步方法：synchronized方法在JVM层面并没有任何特别的指令来实现被Synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中synchronized标识位设置为1，表示方法是同步方法，并使用调用该方法的对象或该方法所属的class在JVM的内部对象做为锁对象。</li></ul><blockquote><p>7.volatile实现原理</p></blockquote><p>volatile是轻量级的锁，它不会引起上下文的切换和调度。</p><ul><li>可见性：对一个volatile修饰的变量进行读操作，总可以看到对这个变量最终的写。</li><li>原子性：对一个volatile修饰的变量读写具有原子性，但是符合操作除外，例如i++。</li><li>禁止重排：JVM底层采用内存屏障来实现volatile语义，防止指令重排序。<br>鉴于这三个特性，volatile经常用于这两个场景：状态标记常量，Double Check。</li></ul><blockquote><p>8.锁的分类，都有那些锁？</p></blockquote><ul><li>可重入锁：在一个线程中可以多次获取同一把锁，ReentrantLock和synchronized都是可重入锁。</li><li>可中断锁：可以中断相应的锁，synchronized不是可中断的锁，Lock是可中断锁。</li><li>公平锁：尽量以请求锁的顺序来获取锁。synchronized是非公平锁，Lock默认是非公平的，但是可以设置成公平锁。</li></ul><blockquote><p>9.说一下ReentrantLock锁</p></blockquote><p>ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。可以等同于synchronized的使用，但是ReentrantLock提供了更加强大，灵活的锁机制，可以减少死锁发生的概率。ReentrantLock实现了Lock接口，基于内部sync实现，Sync实现AQS,提供了FairSync和NonFairSync两种实现。Condition和Lock一起使用以实现等待/通知模式，通过await()和signal()来阻塞和唤醒线程。</p><blockquote><p>10.说一下读写锁</p></blockquote><p>ReentrantReadWriteLock维护一对锁，一个读锁，一个写锁，并发性得到较大的提升。在同一时间内，可以允许多个读线程进行访问，但是，在写线程访问时，所有读线程和写线程都会被阻塞。</p><blockquote><p>11.AQS队列同步器</p></blockquote><p>AQS是构建锁或者其他同步组件基础框架，包含了实现同步器的细节(获取同步状态，FIFO同步队列)。AQS的主要使用方式是继承，子类通过继承AQS,并实现它的抽象方法来管理同步状态。</p><ul><li>维护一个同步状态state，当state&gt;0时，表示已经获取了锁，当state==0时，表示释放了锁。</li><li>AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败(锁)时，AQS则会将当前线程以及等待状态等信息构造成一个节点并将其加入同步队列，同时阻塞当前线程。当同步线程释放时，则会把节点中的线程唤醒，使其再次获取同步状态。</li></ul><blockquote><p>12.synchronized和Lock的区别</p></blockquote><ul><li>Lock是一个接口，synchronized是Java中的关键字，是语言的内置特性。</li><li>synchronized在发生异常时，会自动释放所占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能发生死锁现象，因此，使用Lock时需要在finally块中释放锁。</li><li>Lock可以让等待的线程响应中断，而synchronized不行，使用synchronized时，等待的线程会一直等待下去，不能响应中断。</li><li>通过Lock可以知道是否获成功获取锁，而synchronized无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。</li></ul><blockquote><p>13.说一下CAS</p></blockquote><p>Compare And Swap 比较交换，synchronized保证了代码块的原子性，但是会引起性能问题，volatile是不错的选择，但是不能保证原子性。所以需要CAS来保证原子性。<br>CAS有三个参数，内存值V，旧的预期值A，要更新的值B，当且仅当内存值V的值等于旧的预期值A时，才会将内存值V修改为B，否则什么都不干。</p><blockquote><p>14.HashMap是线程安全的嘛？如何变得安全？</p></blockquote><p>不是线程安全的，添加元素到map中时，数据量大产生扩容操作，多线程导致HashMap的node链表形成环状的数据结构导致死循环，所以HashMap是线程不安全的。可以通过Collections.synchronizedMap()方法对HashMap进行包装，返回一个SynchronizedMap对象，在源码中SynchronizedMap也是通过synchronized方法来保证线程安全的。JUC包中的ConcurrentHashMap来进行高效安全并发，注意的是key和value都不能为null。</p><blockquote><p>15.ConcurrentHashMap的实现方式</p></blockquote><p>JDK1.7中采用分段锁和HashEntry使锁更加细化，其中Segment继承于ReentrantLock，理论上支持ConcurrentLevel(Segment数组数量)的线程并发。</p><p>JDK1.8采用CAS+synchronized来保证并发更新的安全，当然底层使用数组+链表+红黑树的存储结构。<br>table中存放Node节点数据，默认Node数据大小为16，扩容大小总是2^N,为了保证可见性，Node节点中的val和next节点都用volatile修饰，当链表长度大于8时，会转换成红黑树，节点会被包装成TreeNode放在TreeBin中。</p><ul><li>put操作:<ul><li>计算key对应的hash值，</li><li>如果hash表还未初始化，调用的intTable()进行初始化，否则在table中找到index位置，并通过CAS添加节点，如果链表长度超过8，则将链表转换为红黑树，如果节点总数超过，则进行扩容。</li></ul></li><li>get操作：<ul><li>无需加锁，直接根据key的hash值遍历node</li></ul></li></ul><blockquote><p>16.CountDownLatch和CyclicBarrier的区别</p></blockquote><p>CyclicBarrier允许一组线程相互等待，直到到达某个公共的屏障点，每个线程都调用await()方法，告诉CyclicBarrier我已经到达屏障，然后当前线程被阻塞，当所有的线程都到达了屏障，结束阻塞，所有的线程可继续执行后续逻辑。<br>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后再继续执行，使用一个计数器实现，计数器初始值为线程的数量，当每个线程完成自己任务后，计数器的值就会减一，当计数器的值为0时，表示所有的线程都完成了任务，然后CountDownLatch上等待的线程就可以恢复执行任务。</p><blockquote><p>17.什么是乐观锁和悲观锁？</p></blockquote><p>像synchronized这种独占锁属于悲观锁，它是在假设一定会发生冲突，那么加锁恰好有用，除此之外，还有乐观锁，乐观锁就是假设没有冲突发生，那么我正好可以进行某项操作，如果要是发生冲突呢？那我就重试直到成功，乐观锁最常见的就是CAS。</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><blockquote><p>1.ClassLoader的种类，父子关系(不一定是继承)，双亲委派机制，Java为什么要用双亲委派机制?</p></blockquote><p>【种类】<br>ClassLoader包括：引导类加载器(BoostrapClassLoader)、扩展类加载器(ExtensionsClassLoader)、应用类程序加载器(ApplicationClassLoader)、自定义类加载器</p><ul><li>引导类加载器：加载JVM自身需要的类，由C++实现，是虚拟机的一部分，负责将lib下和核心类库和-Xbootclasspath参数指定路径下的jar包加载到内存中，而且虚拟机加载的jar包的时候是根据jar包文件名来识别的，比如rt.jar,如果文件名不被虚拟机识别，即使把jar包放在lib下边也不会被加载，并且BootstrapClassLoader只加载包名为java、javax、sun等开头的类，这些都是为了虚拟机的安全考虑。</li><li>扩展类加载器：负责加载JAVA_HOME/lib/ext目录下或者由虚拟机参数指定的<code>-Djava.ext.dir</code>指定路径中的类库。</li><li>应用类程序加载器：ApplicationClassLoader是指sun公司实现的<code>sun.misc.Launcher$AppClassLoader</code>,负责加载系统类路径<code>java -classpath</code>或者<code>-Djava.class.path</code>下的类库，一般情况下，这个是默认的类加载器，通过<code>ClassLoader#getSystemClassLoader()</code>方法可以获取。</li><li>自定义类加载器：通过继承<code>java.lang.ClassLoader</code>并重写<code>findClass()</code>方法来实现。</li></ul><p>【父子关系】</p><ul><li>启动类加载器，由C++实现，没有父类</li><li>扩展类加载器，由Java实现，父类为Null，其实是启动类加载器，但是启动类加载器不是Java实现实现的，所以获取到的是Null</li><li>系统类加载器，由Java实现，父类加载器为扩展类加载器</li><li>自定义类加载器，由Java实现，父类加载器为系统类加载器</li></ul><p> 【双亲委派机制】<br> 如果一个类收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，请求最终到达顶层的启动类加载器，如果父类加载器可以完成加载任务，则成功返回，倘若父类加载器无法完成此加载任务，子类加载器才会去尝试加载，这就是双亲委派机制。但是这个翻译不应该叫双亲，应该叫好爸爸机制，因为子类都是不管怎样都是先丢给父类来加载，只有父类加载不了子类才会去加载。</p><p> 【双亲委派机制好处】<br> 为什么要用双亲委派机制呢？肯定是因为这种机制有某个好处使得官方采用。<br> （1）避免类的重复加载。当父类加载器加载了该类时，就没有必要子ClassLoader再加载一次。<br> （2）安全因素考虑，Java核心API中定义的类不会被改变，防止核心API库被随意修改。</p><blockquote><p>2.如何打破双亲委派机制?什么时候需要打破双亲委派机制？有哪些框架打破了双亲委派机制？</p></blockquote><p>打破双亲委派机制不仅要继承<code>java.lang.ClassLoader</code>重写<code>findClass()</code>方法，还要重写<code>loadClass()</code>方法，默认的<code>loadClass()</code>方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。因此为了打破双亲委派机制就必须重写<code>loadClass()</code>,可以在这个方法里边使用任何一个类加载器来加载，不一定优先由启动类加载器来加载，这样子就打破了双亲委派机制。</p><p>什么时候需要打破双亲委派机制呢？双亲委派机制很好的解决了各个类加载器的基础类统一问题，越基础的类越由上层的类加载器加载，基础类之所以叫做基础类，是因为他们总是作为被调方被别人调用，但是，如果基础类想调用户的代码，这个时候怎么办呢？这并非不可能的事，这个时候就需要打破双亲委派机制，一个典型的例子就是JNDI服务，它的代码由引导类启动器去加载，但是JNDI的目的就是对资源进行集中管理和查找，需要调用各个厂商实现部署在应用程序的classpath下的JNDI接口提供者(SPI)的代码，但是引导类加载器不认识这些代码，该如何解决呢？引入线程上下文加载器，这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个,如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型。还有一个就是OSGi,为了可以动态加载模块，每个模块都有自己类加载器，这些类加载器组成了网状结构，不再是双亲委派模型中的树状结构。</p><blockquote><p>3.JVM内存结构</p></blockquote><p>JVM内存结构主要有三大块：堆内存、方法区和栈。<br>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配<br>方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)<br>栈又分为java虚拟机栈和本地方法栈,主要用于方法的执行</p><blockquote><p>4.对象是否可GC</p></blockquote><p>这个问题其实就是JVM如何判断对象是否需要被回收，JVM使用可达性算法来计算一个对象是否可达。<br>算法思路：通过一些被列为”GC Roots“的对象作为起始点，从这些点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，则说明对象需要被回收。<br>可以作为GC Roots对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><blockquote><p>5.Minor GC、Major GC和 Full GC</p></blockquote><p>堆内存由年轻代和老年代组成。<br>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。<br>Major GC 是清理老年代。<br>Full GC 是清理整个堆空间—包括年轻代和老年代。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote><p>1.MySQL数据库的底层原理</p></blockquote><p>MySQL数据库是C/S架构模式，我们关心的是Server端，也就是mysqld这个进程。MySQL服务端是二层架构：<br>1.SQL层(SQL Layer),在MySQL数据库系统处理底层数据之前的所有工作都是在这一层完成，包括权限判断，SQL解析，执行计划优化，查询缓存的处理等等。具体模块及职责如下:</p><ul><li>初始化模块: MySQL Server启动的时候做初始化操作</li><li>核心API: 提供一些非常高效的底层操作功能的优化实现</li><li>网络交互模块: 抽象底层网络交互所使用的api，实现底层网络数据的接收与发送</li><li>Client&amp;Server交互协议模块: MySQL 客户端和服务端交互的协议实现，基于TCP/IP,Socket等</li><li>用户模块: 用户管理模块，包括用户的登录连接权限以及用户的授权管理</li><li>访问限制模块: 根据用户模块的授权信息来控制用户对数据的访问</li><li>连接管理模块: 负责监听对MySQL Server的各种请求，接收连接请求，转发所有的连接请求到线程管理模块，每一个连接上MySQL Server的客户端请求都会被分配或者创建一个连接线程为其单独服务</li><li>Query解析和转发模块: 连接线程接收到客户端的一个Query之后，将Query分类后转发给各个对应的处理模块</li><li>Query Cache模块: 将客户端提交给MySQL的Select类Query请求的返回结果集缓存到内存中，与该Query的一个Hash值做一个对应。当取数据的基表发生变化之后，缓存失效</li><li>Query 优化器模块: 优化客户端请求的Query，根据一些算法来得出最优的策略，告诉程序如何去取这个Query语句的结果</li><li>表变更管理模块: 负责完成DDL、DML的Query，比如update，delete，insert，create table，alter table等语句的处理</li><li>表维护模块: 表的状态检查，错误修复</li><li>系统状态管理模块: 在客户端请求系统状态的时候，将各种系统状态返回给用户，比如show status,show variables等</li><li>表管理器: 维护.frm文件，以及一个Cache,缓存各个表的结构信息。</li><li>日志记录模块: 负责的整个系统的日志记录</li><li>复制模块: 分为Master模块和Slave模块，Master模块主要负责在Replication环境下读取Master节点的binary日志，以及和Slave端的IO线程交互。Slave模块有两个线程(IO线程和SQL线程)，IO线程从Master请求和接受binary日志，并写入本地relay log。SQL线程从relay log中读取日志事件，解析成可以执行的SQL语句，然后顺序执行，这样子从节点就和主节点的数据基本上保持一致。</li><li>存储引擎接口模块: 将各种数据处理高度抽象化，各种存储引擎产品实现接口即可，实现了MySQL特有的可插拔存储引擎。</li></ul><p>2.存储引擎层(Storage Engine Layer),底层数据的存取都是在这一层做的，常用的存储引擎有InnoDB引擎和MyISAM引擎。</p><blockquote><p>2.InnoDB引擎和MyISAM引擎的区别和应用场景</p></blockquote><p>从这两种存储引擎的优缺点来谈区别以及应用场景<br>【InnoDB】<br>优点：支持事务，支持外键<br>缺点：占用磁盘多，读效率慢于MyISAM<br>【MyISAM】<br>优点：查询较快（读取数据不加锁），支持多种存储方式（静态表，压缩表等）<br>缺点：写入较慢（锁表），没有事务。</p><p>结论：支持事务选InnoDB,对读有要求的选MyISAM。</p><blockquote><p>3.数据库索引的原理，分类</p></blockquote><blockquote><p>4.B+树有了解吗？为什么MySQL选用B+树做主要存储结构，为什么常用索引推荐使用B+树？为什么B+树可以减少磁盘IO?</p></blockquote><blockquote><p>4.如何避免索引失效？</p></blockquote><blockquote><p>5.有处理过MySQL优化吗？如何优化？</p></blockquote><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="SpringFramework"><a href="#SpringFramework" class="headerlink" title="SpringFramework"></a>SpringFramework</h3><blockquote><p>1.简单谈谈Spring的IOC和AOP,都在哪些场景用到过？</p></blockquote><p>IOC是控制反转，就是对象的创建工作交给Spring容器来做，程序员不需要new出来，需要什么就跟Spring容器要，前提是容器里边有这个对象，底层实现是反射。AOP是面向切面编程，在记录日志，权限控制，事务方面都有应用，底层实现是动态代理。</p><blockquote><p>2.Spring中Bean生命周期过程，以及两种作用域Singleton和Prototype有什么区别，应用场景有哪些？</p></blockquote><p>生命周期:<br>1.Bean的建立：有BeanFactory读取Bean定义文件，并生成各个实例</p><p>2.Setter注入：执行Bean的属性依赖注入</p><p>3.BeanNameAware的setBeanName()：如果Bean实现了org.springframework.beans.factory.BeanNameAware接口，则执行其setBeanName()方法</p><p>4.BeanFactoryAware的setBeanFactory()：如果Bean实现了org.springframework.beans.factory.BeanFactoryAware接口，则执行其setBeanFactory()方法</p><p>5.BeanPostProcessors的processBeforeInitialization()：容器中如果有实现org.springframework.beans.factory.BeanPostProcessors接口的实例，则任何Bean在初始化之前都会执行这个实例的processBeforeInitializaton()方法</p><p>6.InitializingBean的afterPropertiesSet()：如果Bean类实现了org.springframework.beans.factory.InitailizingBean接口，则执行去afterPropertiesSet()方法</p><p>7.Bean定义文件中定义init-method：如果在xml文件中定义一个Bean的时候指定了init-methond，则执行这个方法，并且这个初始化方法是不能带有参数。</p><p>8.BeanPostProcessors的processAfterInitializaton()：容器中如果有实现org.springframework.beans.factory.BeanPostProcessors接口的实例，则去执行processAfterInitialization()方法</p><p>9.DisposableBean的destroy()方法：在容器关闭时，如果Bean实现了org.springframework.beans.factory.DisposableBean接口，则执行它的destroy()方法</p><p>10.Bean定义文件中定义destroy-method：在容器关闭时，执行destroy-method()方法，并且这个方法是不带参数的</p><p>作用域：<br>【singleton】：单例，每次访问都是返回同一个实例，Spring默认，无状态的Bean都应该使用Singleton，比如需要回收的重要资源(数据库连接池，线程池)<br>【prototype】：多例，每次访问都会进行new操作，Spring不会对Bean的整个生命周期进行负责，具有prototype的作用域的Bean创建后交由调用者负责销毁对象回收资源，有状态的Bean应该配置成prototype</p><blockquote><p>3.AOP动态代理模式的两种类型,区别是什么？</p></blockquote><p>AOP动态代理有两种：JDK代理和CGLIB代理，JDK代理只能对实现了接口的类进行代理，而不能针对未实现接口的类。CGLIB代理是针对类(未使用final修饰)实现代理,主要是对指定的类生成一个子类，覆盖其中的方法，底层是使用ASM字节码生成框架，使用字节码技术生成代理类。<br>Spring是怎么选择使用哪种代理的呢？如果一个Bean实现了接口，那么默认使用JDK代理，当Bean没有实现接口时，Spring默认使用CGLIB代理。</p><blockquote><p>4.Spring事务的特性，隔离级别，传播行为</p></blockquote><p>特性：<br>1.原子性(Atomicity)： 事务的不可分割性<br>2.一致性(Consistency)：事务执行前后数据的完整性保持一致<br>3.隔离性(Isolation)：事务执行过程中，不应该受到其他事务的干扰<br>4.持久性(Durability)：事务一旦结束，数据就持久到数据库</p><p>如果事务不考虑隔离性，就会引发安全性问题。比如：<br>1.脏读：一个事务读到了另一个事务未提交的数据<br>2.不可重复读：一个事务读到了另一个事务已经提交的update数据导致多次查询结果不一致<br>3.虚幻读：一个事务读到了另一个事务已经提交的insert的数据导致多次查询结果不一致</p><p>为了解决这个问题，引出事务隔离级别：<br>1.默认(default)：默认的隔离级别，使用数据库的默认隔离级别<br>2.未提交读(read uncommited)：脏读，不可重复读，虚幻读都有可能发生<br>3.已提交读(read commited)：避免脏读，但是不可重复读和虚幻读还是有可能发生<br>4.可重复读(repeatable read)：避免脏读和不可重复读，但是虚幻读还是有可能发生<br>5.串行化(Serializable)：避免上述所有读问题</p><p>MySQL默认的隔离级别是可重复读，Oracle默认的隔离级别是已提交读</p><p>事务的传播行为：<br>1.保证同一个事务中<br>PROPAGATION_REQUIRED：支持当前事务，如果不存在就新建一个<br>PROPAGATION_SUPPORTS：支持当前事务，如果不存在，就不使用事务<br>PROPAGATION_MANDATORY：支持当前事务，如果不存在就抛异常<br>2.保证没有在同一个事务中<br>PROPAGATION_REQUIRED_NEW：如果有事务存在，挂起当前事务，创建一个新的事务<br>PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务<br>PROPAGATION_NEVER：已非事务方式运行，如果有事务存在，则抛出异常<br>PROPAGATION_NESTED：如果当前事务存在，则已嵌套事务执行</p><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><blockquote><p>1.SpringMVC的作用，与Struct的区别是什么？</p></blockquote><p>SpringMVC是一个基于请求驱动的Web框架，使用了前端控制器模式来设计，再根据请求映射规则分发给相应的页面控制器进行处理。简单点就是处理http请求和响应。<br>区别：</p><ul><li>SpringMVC是基于Servlet来实现，Struct是基于Filter来实现的。</li><li>SpringMVC是基于方法级别的拦截，一个方法对应一个request上下文，Controller Bean默认是sigleton的，只会创建一个Controller，但是没有共享的属性，所以是线程安全。Struct是基于类级别的拦截，每次请求都会创建一个Action，Action Bean在Spring容器中是prototype的，通过setter方法将request注入到属性当中。</li></ul><blockquote><p>2.SpringMVC的工作原理，都涉及到哪些类？</p></blockquote><p>1.用户发送请求至前端控制器DispatherServlet</p><p>2.DispatherServlet接收到请求之后调用HandlerMapping处理映射器</p><p>3.处理映射器找到具体的处理类(xml配置，注解)，生成处理器对象及处理拦截器一并返回给<br>DispatherServlet</p><p>4.DispatherServlet调用HandlerAdapter处理适配器</p><p>5.HandlerAdapter经过适配调用具体的处理器(Controller)</p><p>6.Controller执行完成返回ModelAndView对象</p><p>7.HandlerAdapter将ModelAndView返回给DispatherServlet</p><p>8.DispatherServlet将ModelAndView对象返回给ViewResolver视图解析器</p><p>9.ViewResolver解析后返回具体的View</p><p>10.DispatherServlet根据View进行渲染视图</p><p>11.DispatherServlet响应用户</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><blockquote><p>1.Mybatis有什么优缺点</p></blockquote><p>【优点】<br>1.基于SQL编程，SQL写在XML里边，与程序解耦，对JDBC做了进一步的封装，消除JDBC大量冗余的代码。<br>2.与Spring有很好的集成<br>3.提供映射标签，支持对象与数据库的ORM字段关系映射，提供对象关系映射标签，支持对象关系组件维护<br>【缺点】<br>1.SQL语句工作量大，尤其是字段多或者关联表多的时候。<br>2.SQL依赖于数据库，不能随意更换数据库</p><p>适用场景：<br>专注于SQL，提供足够灵活的DAO解决方案<br>对性能有要求或者需求变化比较多的项目</p><blockquote><p>2.#{}和${}的区别</p></blockquote><p>#{}是预编译处理，\${}是字符串替换<br>Mybatis在处理#{}时，会将SQL中的#{}替换为?,调用PrepareStatement的set()方法来赋值，所以，#{}可以有效的防止SQL注入。处理\${}时，就是把\${}替换成变量的值。</p><blockquote><p>3.实体类中的属性名和表中的字段名不一样你怎么处理？</p></blockquote><p>两种方案<br>（1）resultType是实体类，查询SQL语句中定义字段名的别名，让字段名的别名和实体类属性名一致。<br>（2）resultMap映射，将字段名和属性名的一一对应起来</p><blockquote><p>4.模糊查询like怎么写？</p></blockquote><p>两种写法<br> (1) 在Java代码中添加sql通配符%号<br> (2) 在SQL语句中拼接通配符，会引起SQL注入，不推荐</p><blockquote><p>5.通常一个xml映射文件都会与一个Mapper接口相对应，讲一下Mapper接口的工作原理，还有Mapper接口里的方法可以重载吗？</p></blockquote><p>Mapper接口的全限名，就是xml文件中的namespace值，Mapper接口中的方法名，就是xml中MappedStatement中的id值，Mapper接口中方法的参数，就是传递给SQL的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名可以唯一定位一个MappedStatement。</p><p>Mapper接口中方法是不能重载的，因为是通过全限名+方法名来保存和寻找MappedStatement的。</p><p>Mapper接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理Proxy对象，代理对象Proxy会拦截接口方法，转而执行MappedStatement所代表的SQL，然后将SQL执行结果返回。</p><blockquote><p>6.Mybatis是如何进行分页的？分页插件的原理是什么？</p></blockquote><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL，然后重写SQL，根据direct方言，添加对应的物理分页语句和物理分页参数。</p><blockquote><p>7.Mybatis如何实现一对一查询？</p></blockquote><p>连表查询，只查询一次，通过在resultMap里边配置association节点配置一对一的类就可以完成。</p><blockquote><p>8.Mybatis如何实现一对多查询？</p></blockquote><p>连表查询，只查询一次，通过在resultMap里边配置collection节点配置一对多的类就可以完成。</p><blockquote><p>9.Mybatis是否支持延迟加载，如果支持，实现原理是什么？</p></blockquote><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的是一对一，collection指的是的一对多，在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnable=true|false</p><p>实现原理是使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的SQL，把B查询出来，然后调用a.setB(b)，这样子a.getB()就有值了，接着完成a.getB().getName()方法的调用，这就是延迟加载的原理。</p><blockquote><p>10.Mybatis的一级缓存和二级缓存</p></blockquote><p>一级缓存，基于PrepetualCache的HashMap本地缓存，其存储作用域为本地Session，当Session flush或者close之后，该Session中的所有Cache就将清空，默认打开一级缓存。</p><p>二级缓存，默认也是采用PrepetualCache的HashMap缓存，不用在于其存储作用域为Mapper,或者说是namespace，并且可以自定义存储源，比如Ehcache，默认二级缓存是不开启的，要开启二级缓存，使用二级缓存属性类需要实现序列化接口，在映射文件中配置<cache></cache></p><blockquote><p>11.接口是如何绑定的？</p></blockquote><p>接口绑定有两种方式，一种是通过注解绑定，一种是通过xml绑定。<br>注解绑定就是在接口的方法上面加上@Select,@Update等注解，注解里边写SQL语句。<br>xml绑定就是xml里边用特定的标签来写SQL语句,通过namespace+id来绑定。</p><blockquote><p>12.使用Mybatis的Mapper接口调用时有哪些要求？</p></blockquote><p>（1）xml中namespace即接口的全限名<br>（2）Mapper接口方法名和xml中定义的每个SQL的id相同<br>（3）Mapper接口方法的输入参数类型和xml中定义的SQL的parameterType的类型相同<br>（4）Mapper接口方法的输出参数类型和xml中定义的SQL的resultType的类型相同</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><blockquote><p>1.为什么使用消息队列？</p></blockquote><p>消息队列最主要的三个应用场景:解耦、异步、削峰。</p><p>引入消息中间件进行系统解耦，一般使用订阅模式，强耦合的系统通过发布消息到消息队列中，其他系统通过订阅模式来获取消息之后触发来处理业务逻辑，从而实现系统间的解耦，不至于要对接一个新的系统的又要改代码，解耦非常有用，也是很重要的。</p><p>再来说说异步，一些非必要的业务逻辑以同步的方式运行，非常耗时间，特别是调用链很长的时候，不需要同步的等待其他系统调用返回，改进用户体验，类似于单体系统中的线程。</p><p>最后再来说说削峰，我们做的系统的几乎没有什么并发量，但是我可以说说这块的理解，当并发量大的时候，大量的请求涌向数据库连接池，连接池处理不了那么多，只能不断的报数据库连接异常，大量的请求累计会把系统搞垮，这时候就需要消息中间件来的削峰，所有的请求都进入消息队列，然后系统再从队列里按照自己能处理的并发量慢慢拉取消息来处理，这样子就把大并发压力转移到消息队列中间件。</p><blockquote><p>2.使用消息队列的缺点</p></blockquote><p>引入了消息队列这种技术就要知道缺点是什么，能不能cover住这个技术，不然那就是给自己挖坑。</p><p>原本的系统运行的好好的，现在你引入了一个中间件，如果中间件挂了，那你的系统是不是就没法正常运行了，这将会给公司带来直接的经济损失，系统的可用性降低。</p><p>系统的复杂性增加，引入了消息中间件，要考虑很多方面的问题，比如一致性问题，如何保证消息不被重复消费，如何保证消息的可靠传输等等。</p><p>这两个问题都直接涉及到MQ的选型问题。</p><blockquote><p>3.那么多种mq，为什么选择这种，怎么做的技术选型？</p></blockquote><p>技术选型这个该怎么说呢？虽然还轮不到咱，但是我们自己也要懂，总有一天会轮到我们的。做技术选型首先就是要了解都有哪些主流的产品，都有什么优缺点，如果出现了问题我们自己是否能cover住，即使不能，社区会不会解决？活跃度怎么样，这些都是需要了解比较的，然后选出一个能够满足业务前提下的最优的一种产品。</p><p>ActiveMQ, Java语言开发，单机吞吐量万级，延时ms级，主从架构，可用性高，产品成熟，文档全面。社区活跃度低。<br>RabbitMQ, Erlang语言开发，单机吞吐量万级，延时us级，主从架构，可用性高，并发能力很强，性能及其好，延时很低，管理界面较丰富，社区活跃度高。<br>RocketMQ, Java语言开发，单机吞吐量10万级，延时ms级，分布式架构，可用性非常高，MQ功能完备，扩展性级佳,阿里出品，微众银行也有一个分支，质量值得信赖。<br>Kafka, Scala语言开发，单机吞吐量10万级，延时ms级，分布式架构，可用性非常高，只支持MQ的主要功能，像消息查询，回溯等功能未提供，因为其主要应用场景是大数据领域而非MQ。</p><p>综上，可以根据业务场景和团队能力进行技术选型。比如Java小团队，吞吐量不是很大，可以优先选择RabbitMQ，Java中大型团队可以考虑RocketMQ来进行改造，挑战更高的性能。如果是日志采集或者大数据方面的场景，当然要选Kafka了。</p><blockquote><p>4.如何保证消息不被重复消费？或者说如何保证消息队列的幂等性？</p></blockquote><p>什么时候会造成消息重复消费呢？我没有遇到过这种情况，我觉得可能是网络原因造成，正常情况下，消费者在消费完消息后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除，像RabbitMQ会发送一个ACK确认信息，如果确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息发给其他的消费者。</p><p>如果拿到这个消息来做数据库的插入操作，那就给这个消息做一个主键操作，这样子即使重复消费了也会导致主键冲突，避免数据库出现脏数据。</p><p>如果拿到这个消息之后是放到redis里边，那同样也是不需要解决的，redis的set操作就是幂等操作。</p><p>如果还不行，可以借助第三方来做一个消费记录，可以是redis，给消息分配一个全局唯一id，只要消费过该消息，将&lt;id,message&gt;写入redis，消费者在开始消费前，先去redis中查询有没有消费记录即可。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><blockquote><p>1.谈谈TCP/IP模型</p></blockquote><p>这个问题可以从OSI七层模型谈起引出TCP/IP五层模型，OSI是学术定义，但是不实用，工业界使用的是TCP/IP。<br>OSI七层模型:</p><ul><li>应用层 针对特定的协议，为应用程序做服务,比如SMP,POP3,SSH,FTP等协议。</li><li>表示层 负责数据格式的转换，把不同表现形式的信息转换成适合网络传输的格式。</li><li>会话层 负责建立和断开通信连接，什么时候建立连接，什么时候断开连接以及保持多久的连接。</li><li>传输层 在两个通信节点之间负责数据的传输，起着可靠传输的作用。(运行在这一层的设备有四层交换机，四层路由器)</li><li>网络层 路由选择，在多个网络之间转发数据包，负责将数据包传送到目的地址。(运行在这一层的设备有路由器，三层交换机)</li><li>数据链路层 负责物理层面互联设备之间的通信传输，比如一个以太网相连的两个节点之间的通信，是数据帧与1、0比特流之间的转换。(运行在这一层的设备是网桥、以太网交换机、网卡)</li><li>物理层 主要是1、0比特流与电子信号的高低电平之间的转换。(运行在这一层的设备是中继器、双绞线)</li></ul><p>TCP/IP五层模型:<br>七层模型中的应用层、表示层、会话层在这个模型中都属于应用层，其他四层不变。</p><blockquote><p>2.TCP的三次握手和四次挥手，为什么要这样子设计？</p></blockquote><p>【三次握手】<br>1.客户端发起连接请求，发送SYN=1和客户端序号c给服务器端，同时进入SYN_SENT状态。<br>2.服务端收到SYN后需要作出确认，于是发送ACK=1,同时自己也发送SYN=1,服务端序号s，同时发送确认号c+1(表示下一个接受序号),进入SYN_RCVD状态。<br>3.客户端收到服务端的SYN和ACK,作出确认，发送ACK=1，以及序号c+1的数据，同时发送确认号s+1(表示客户端下一个要接收的序号)。此时客户端和服务端进入ESTABLISHED状态，确认过眼神，状态已经建立。</p><p>【四次挥手】<br>1.客户端发起断开请求，发送FIN=1和序号c给服务端，客户端进入FIN-WAIT-1状态。<br>2.服务端收到FIN后作出确认，发送ACK=1和服务端序号s,确认号c+1(表示下一个接收序号),服务端此时还可以向客户端发送数据,服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。<br>3.服务端没有数据发送时，它向客户端发送FIN=1,ACK=1,请求断开连接，同时发送服务端序号s，确认号c+1,服务端进入LAST-ACK状态。<br>4.客户端收到之后进行确认，发送ACK=1,以及序号c+1和确认号s+1。客户端进入TIME-WAIT状态，客户端需要等待2MSL,确保服务端收到了ACK，若这期间没有服务端的消息，便可认为服务端收到了确认，此时可以断开连接。服务端和客户端进入CLOSED状态。</p><p><img src="/asset/img/interview-summary/tcp_shake_hand.jpg" alt="TCP三次握手四次挥手"></p><p>为什么这样子设计呢？握手两次行不行？</p><p>两次握手的话，只要服务端发出确认就建立连接了。有一种情况是客户端发出了两次连接请求，但由于某种原因，使得第一次请求被滞留了。第二次请求先到达后建立连接成功，此后第一次请求终于到达，这是一个失效的请求了，服务端以为这是一个新的请求于是同意建立连接，但是此时客户端不搭理服务端，服务端一直处于等待状态，这样就浪费了资源。假设采用三次握手，由于服务端还需要等待客户端的确认，若客户端没有确认，服务端就可以认为客户端没有想要建立连接的意思，于是这次连接不会生效。</p><p>四次握手，为什么客户端发送确认后还需要等待2MSL?</p><p>因为第四次握手客户端发送ACK确认后，有可能丢包了，导致服务端没有收到，服务端就会再次发送FIN = 1，如果客户端不等待立即CLOSED，客户端就不能对服务端的FIN = 1进行确认。等待的目的就是为了能在服务端再次发送FIN = 1时候能进行确认。如果在2MSL内客户端都没有收到服务端的任何消息，便认为服务端收到了确认。此时可以结束TCP连接。</p><blockquote><p>3.有了传输层为什么还要网络层？</p></blockquote><p>网络层是针对主机与主机之间的服务。而传输层针对的是不同主机进程之间的通信。网络层负责将数据包从源IP地址转发到目标IP地址，而传输层负责将数据包再递交给主机中对应端口的进程。</p><blockquote><p>4.TCP序号的作用，怎么样保证可靠传输？</p></blockquote><p>序号和确认号是实现可靠传输的关键。<br>序号-当前数据包的首个字节的顺序号，确认号-表示下一个想要接收的字节序号，并且已经正确收到确认号之前的所有字节。<br>通信双方通过序号和确认号来判断数据是否丢失，是否按顺序到达，是否冗余等等，如果丢失了就重传，如果冗余了就丢弃，换句话说，序号，确认号和重传机制保证了数据不丢失、不重复。</p><blockquote><p>5.TCP和UDP的区别</p></blockquote><ul><li>TCP面向连接，传输数据之前需要建立会话，UDP是无连接的</li><li>TCP是可靠传输，UDP只负责发送数据，不保证接收方是否接收，不保证可靠</li><li>TCP面向字节流，UDP面向报文</li><li>TCP只支持点到点通信，UDP支持点到点、点到面、面到面的通信</li></ul><blockquote><p>6.浏览器的一个HTTP请求到后端的一个大致过程是怎样的？</p></blockquote><p>1.利用DNS进行域名解析(先找本地hosts再找运营商的DNS服务器)<br>2.发起TCP三次握手<br>3.建立TCP连接之后发起HTTP请求<br>4.服务器响应HTTP请求，浏览器得到HTML代码<br>5.浏览器解析HTML代码，并请求HTML代码中的资源(csc,js,image)<br>6.浏览器对页面进行渲染</p><blockquote><p>7.HTTP是基于TCP还是UDP?</p></blockquote><p>HTTP 1.0/1.1 是基于TCP协议，客户端向服务端发送一个HTTP请求时，需要与服务端建立TCP连接，三次握手成功后才会进行数据交互，目前基本上都是HTTP 1.1的。2.0是基于UDP的。</p><blockquote><p>8.HTTP请求和响应的报文结构</p></blockquote><p>HTTP请求报文结构：</p><ul><li>请求头：包括请求方法、URL、HTTP协议版本号</li><li>请求头： 多组键值对</li><li>请求空行：告诉服务器请求头的键值对已经发送完毕</li><li>请求主体</li></ul><p>HTTP响应报文结构：</p><ul><li>响应行：包括HTTP协议版本号、状态码、状态码描述</li><li>响应头：多组键值对</li><li>响应空行：告诉客户端响应头键值对结束</li><li>响应主体</li></ul><blockquote><p>9.HTTP常见的状态码</p></blockquote><ul><li>1xx：信息性状态码，表示接收的请求正在处理</li><li>2xx：成功状态码，表示请求处理完毕</li><li>3xx：重定向状态码，表示需要进行附加操作以完成请求</li><li>4xx：客户端错误状态码，表示服务器无法处理请求</li><li>5xx：服务端错误状态码，表示服务器处理请求出错</li></ul><p>常见的状态码有：</p><ul><li>200 OK,请求被正常处理</li><li>201 created，对象创建成功</li><li>301 Move Permanently，永久性重定向</li><li>302 Found，临时重定向</li><li>400 Bad Request，请求报文中格式不对</li><li>403 Forbidden，对请求的资源没有权限访问</li><li>404 Not Found，在服务器上找不到请求资源</li><li>405 Method Not Allowed，请求方法不允许</li><li>500 Internal Server Error，服务器内部错误</li></ul><blockquote><p>10.GET和POST区别</p></blockquote><ul><li>GET用于获取数据，POST用于提交数据</li><li>GET的参数长度有限制，POST没有限制</li><li>GET把参数放在url中，POST通过封装参数到请求体中发送</li><li>GET请求只能进行url编码，POST支持多种编码方式</li><li>GET比POST参数更不安全，因为参数暴露在url上，所以不能用来传递敏感信息</li><li>GET具有幂等性，多次请求得到的结果一样，POST不具备幂等性，多次请求会有重复提交问题</li><li>GET请求会被浏览器保存为历史记录，POST请求不能</li><li>GET请求产生一个TCP数据包，POST产生两个TCP数据包<br>对于GET请求方式，浏览器会把header和data一起发送出去，服务器接收请求返回数据<br>对于POST请求方式，浏览器先发送header，服务器响应100继续，浏览器在发送data，服务器接收请求返回数据</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>1.常见的排序算法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职场系列(一)</title>
      <link href="/2018/12/15/talk-recent/"/>
      <url>/2018/12/15/talk-recent/</url>
      
        <content type="html"><![CDATA[<p>自从把博客自动化构建弄好了之后工作上就特别的忙，加班有点多，每天都是8点半左右才下班，回去之后太累了，不太想写东西，甚至有时候还要远程再工作一会儿，不过还是发生了挺多事的。</p><a id="more"></a><p>原来的研发中心分成了两个团队，我们团队划分出去，和其他研发团队，运维团队以及解决方案组成了一个新的大BU,然后我的直属主管也调到了其他团队，这算是毕业以来经历的最大的调动，不管是团队还是技术，所以这段时间一直以来就是加班，加班，加班。这段时间做的是SDN相关的事情，月底就要发布了，现在处于项目相对轻松的阶段，终于可以闲下来写点东西了，不过上周五开周会主管说12月份要开始做产品大版本了，要进行微服务化，听说划分了三十几个微服务，可以预见明年又是加班的一年，忙里偷闲写点东西吧，谈谈自己最近的一些想法。</p><h2 id="机遇"><a href="#机遇" class="headerlink" title="机遇"></a>机遇</h2><p>组建了新的部门，人员流动很大，团队的积极性也是最高涨，解决问题也是非常方便了，前后端拉通之后不再跨部门沟通，沟通成本直线下降，很佩服大BOSS的执行力！我们工作虽然没有改变多少，但是对我们团队而言，特别是对我来说，工作上的提升是大家都看得到的，得到了大BOSS，项目经理，一线运维同事的口头邮件等形式的表扬，这些都直接体现在工资绩效上面（捂脸逃~）,而且工作中心移向了SDN和负责一些项目开发管理，自我感觉这半年来在技术上以及处事能力上都比以前好了很多。体现就是在SDN产品开发中，负责相对一些基础组件的开发，其他的功能都是在这个之上进行开发的，所以对我的开发质量和进度都有一定的要求，</p><p>还有就是开始处理一些现场的问题，处理的有点多了，但是印象很深的就是一个线上的MySQL问题，运行一段时间之后应用打开非常慢，根本使用不了，当天主管请假了，让我去处理，机缘巧合的情况下促成了一段线上定位，优化的跌宕起伏经历，以后打算用一篇文章总结出来。</p><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>为啥讲能力这个问题呢？我承认自己还是一只菜鸟，不过我这只菜鸟要飞了，只要一直飞就行。工作一年半了，发现能力与年龄不是正相关的，甚至可以说跟年龄都没啥关系，非要说有相关性的话，我觉得它们的皮尔逊相关系数最多0.3，不能再多了！</p><p>为什么我一个菜鸟会有这个想法呢？首先我承认，写程序这个事是需要经验积累的，所以现在很多都是招资深的程序员，能力是与经验和经历成正比，皮尔逊系数可以达到0.8，这个不仅仅是程序员这个行业，大多数行业都是一样。有这个想法的原因是因为在我们团队中有一个人最近在办理离职了，称之为Z吧，Z三十了，技术方面不是很好，就是一年经验用了十年这种，所以在前任主管调离的时候他虽然年纪最大，但是得到提携的并不是他，而是一个工作了四年的人。之前和前任主管私下交流过，前任主管说他的技术和经验是严重不匹配的，虽然能干活，但是干的活很坑，坑过不少人，我就被坑过两次，都是我来填坑，以至于后来跟他合作我都得处处考虑会不会有坑。</p><p>其实吧，有坑不可怕，可怕的是挖坑的人没有担当，我也是被迫填坑之后下定决心的，不管任何时候，任何事情，经过自己手的事情就要敢于担当，总结经验教训，这也是我打算写博客记录的原因之一，而勇于承担这个会反哺给我自己，办的事情越靠谱，给到你的机会就会更多，你的经历也就会更多，能力提升也就会越快。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/03/hello-world/"/>
      <url>/2018/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<!-- ![惠灵顿](/asset/img/Wellington.jpg) --><p>在这里总结自己学习的过程，发现自己很多东西都接触了，但都没有做好总结，这样子是不好的，有输入就应该有输出，这个输出应该是及时的，而不是等到需要跳槽准备面试的时候才做知识的整理和总结。<br><a id="more"></a><br>现在越来越觉得，技术这个东西要的不是广度，而是深度，广度可以在短时间内就可以达成，是一种快消品，而深度不是一朝一夕就可以速成的，需要科班的知识以及后续工作中不断实践做总结才能提升。后续博客里边会对写技术的总结以及我的一些感悟。</p><p>GitHub仓库</p><div class="github-widget" data-repo="ruanzz/ruanzz.github.io"></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
